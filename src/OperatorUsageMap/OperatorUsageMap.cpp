//
// Created by Garry Morrison on 20/11/2020.
//

#include "OperatorUsageMap.h"

OperatorUsageMap operator_usage_map;

OperatorUsageMap::OperatorUsageMap() {
    operator_usage_map.map["empty"] =
            "\nempty:\n"
            "    description:\n\n"
            "    examples:\n\n"
            "    see also:\n";

    operator_usage_map.map["clean"] =
            "\nclean:\n"
            "    description:\n"
            "        clean ket\n"
            "        clean the coefficients of the given superposition\n"
            "        if x < 0, return 0, else return 1\n"
            "        The combination: drop clean sp\n"
            "        converts the given superposition into a \"clean\" superposition\n\n"
            "    examples:\n"
            "        -- clean a superposition:\n"
            "        clean (3|a> + 2.2|b> - 3 |c> + |d>)\n"
            "            |a> + |b> + 0|c> + |d>\n\n"
            "        -- generate a \"clean\" superposition from an arbitrary superposition:\n"
            "        drop clean (3|a> + 2.2|b> - 3 |c> + |d>)\n"
            "            |a> + |b> + |d>\n\n"
            "    see also:\n"
            "        drop, ReLU, invert\n";

    operator_usage_map.map["ReLU"] =
            "\nReLU:\n"
            "    description:\n"
            "        ReLU ket\n"
            "        if x <= 0, return 0, else return x\n"
            "        see: https://en.wikipedia.org/wiki/Rectifier_(neural_networks)\n\n"
            "    examples:\n"
            "        ReLU (3|a> + 2.2|b> - 3 |c> + |d>)\n"
            "            3|a> + 2.200000|b> + 0|c> + |d>\n\n"
            "    see also:\n"
            "        clean, invert\n";

    operator_usage_map.map["invert"] =
            "\ninvert:\n"
            "    description:\n"
            "        invert ket\n"
            "        if x approx == 0, return 0, else return 1 / x\n\n"
            "    examples:\n"
            "        invert (3|a> + 2.2|b> - 3 |c> + |d>)\n"
            "            0.333333|a> + 0.454545|b> - 0.333333|c> + |d>\n\n"
            "    see also:\n"
            "        clean, ReLU\n";


    operator_usage_map.map["drop"] =
            "\ndrop:\n"
            "    description:\n"
            "        drop sp\n"
            "        drop all kets with coeff <= 0 from the given superposition\n\n"
            "    examples:\n"
            "        drop (|a> + 0|b> - 2|c> + 7.1|d>)\n"
            "            |a> + 7.100000|d>\n\n"
            "    see also:\n"
            "        drop-below, drop-above, sdrop\n";

    operator_usage_map.map["filter"] =
            "\nfilter:\n"
            "    description:\n"
            "        filter(operators, conditions) input-seq\n"
            "        Filters the input sequence to only those elements that satisfy the operator/condition pair\n"
            "        It is more powerful than the such-that[] operator, but probably slower\n"
            "        NB: input-seq structure is now preserved\n\n"
            "    examples:\n"
            "        -- learn some knowledge\n"
            "        is-food |bread> => |yes>\n"
            "        is-food |cheese> => |yes>\n"
            "        is-food |steak> => |yes>\n\n"
            "        is-furniture |chair> => |yes>\n"
            "        is-furniture |table> => |yes>\n"
            "        is-furniture |stool> => |yes>\n"
            "        is-furniture |lounge> => |yes>\n\n"
            "        is-day-of-week |monday> => |yes>\n"
            "        is-day-of-week |tuesday> => |yes>\n"
            "        is-day-of-week |wednesday> => |yes>\n"
            "        is-day-of-week |thursday> => |yes>\n"
            "        is-day-of-week |friday> => |yes>\n"
            "        is-day-of-week |saturday> => |yes>\n"
            "        is-day-of-week |sunday> => |yes>\n\n"
            "        -- now try some filters:\n"
            "        -- filter all known kets to those that are furniture:\n"
            "        filter(|op: is-furniture>, |yes>) rel-kets[*]\n"
            "            |chair> + |table> + |stool> + |lounge>\n\n"
            "        -- filter all known kets to those that are food:\n"
            "        filter(|op: is-food>, |yes>) rel-kets[*]\n"
            "            |bread> + |cheese> + |steak>\n\n"
            "        -- filter all known kets to those that are days of the week:\n"
            "        filter(|op: is-day-of-week>, |yes>) rel-kets[*]\n"
            "            |monday> + |tuesday> + |wednesday> + |thursday> + |friday> + |saturday> + |sunday>\n\n\n"
            "        -- an indirect filter example, first learn some knowledge:\n"
            "        father |John> => |Fred>\n"
            "        occupation |Fred> => |politician>\n\n"
            "        father |Sam> => |Robert>\n"
            "        occupation |Robert> => |doctor>\n\n"
            "        father |Emma> => |Jack>\n"
            "        occupation |Jack> => |nurse>\n\n"
            "        -- find people that have a father with occupation nurse:\n"
            "        -- NB: Note the ops: rather than op: to signify operator sequence rather than just an operator\n"
            "        filter(|ops: occupation father>, |nurse>) rel-kets[*]\n"
            "            |Emma>\n\n"
            "        -- find people that have a father with occupation doctor:\n"
            "        filter(|ops: occupation father>, |doctor>) rel-kets[*]\n"
            "            |Sam>\n\n\n"
            "        -- find people that have the father operator defined:\n"
            "        -- which is very close in function to the rel-kets[father] operator\n"
            "        filter(|op: father>, |*>) rel-kets[*]\n"
            "            |John> + |Sam> + |Emma>\n\n"
            "        -- filter to people that have a father with occupation of either doctor or nurse:\n"
            "        filter(|ops: occupation father>, |doctor> + |nurse>) rel-kets[*]\n"
            "            |Sam> + |Emma>\n\n"
            "        -- filter to those that have a rule of any type that is doctor or nurse:\n"
            "        -- NB: if rel-kets[*] is large, or supported-ops is large, this may be slow.\n"
            "        filter(|*>, |doctor> + |nurse>) rel-kets[*]\n"
            "            |Robert> + |Jack>\n\n\n"
            "        -- Finally, filters can be easily chained.\n"
            "        -- Eg, To find all kets that are human, American and are politicians:\n"
            "        -- NB: will be faster if you apply the most strict condition(s) first.\n"
            "        -- Eg, in this case, politician first, then American, then human.\n"
            "        filter(|op: is-human>, |yes>) filter(|op: is-american>, |yes>) filter(|op: occupation>, |politician>) rel-kets[*]\n\n\n"
            "        -- What if we want to find all the known words that are their own plural?\n"
            "        -- first, load some knowledge about words and their plurals:\n"
            "        load plural.sw3\n\n"
            "        -- now the required operator:\n"
            "        -- which returns the input ket if its' plural equals itself, else the empty ket |>\n"
            "        equal-plural |*> #=> filter(|op: plural>, |_self>) |_self>\n\n"
            "        -- now apply it to all known kets:\n"
            "        equal-plural rel-kets[*]\n"
            "            |fish> + |sheep> + |series> + |shrimp> + |species> + |swine> + |trout> + |tuna>\n\n"
            "    see also:\n"
            "        not-filter, such-that, rel-kets\n"
            "        plural.sw3";

    operator_usage_map.map["not-filter"] =
            "\nnot-filter:\n"
            "    description:\n"
            "        not-filter(operators, conditions) input-seq\n"
            "        Filters the input sequence to only those elements that don't satisfy the operator/condition pair\n"
            "        It is the brother of filter()\n\n"
            "    examples:\n"
            "        -- First, learn some knowledge:\n"
            "        father |John> => |Fred>\n"
            "        occupation |Fred> => |politician>\n\n"
            "        father |Sam> => |Robert>\n"
            "        occupation |Robert> => |doctor>\n\n"
            "        father |Emma> => |Jack>\n"
            "        occupation |Jack> => |nurse>\n\n\n"
            "        -- filter to those that don't have a rule of any type that is doctor or nurse:\n"
            "        -- NB: if rel-kets[*] is large, or supported-ops is large, this may be slow.\n"
            "        not-filter(|*>, |doctor> + |nurse>) rel-kets[*]\n"
            "            |John> + |Fred> + |Sam> + |Emma>\n\n\n"
            "        -- find people that don't have the father operator defined:\n"
            "        not-filter(|op: father>, |*>) rel-kets[*]\n"
            "            |Fred> + |Robert> + |Jack>\n\n\n"
            "        -- filter to people that don't have a father with occupation of either doctor or nurse:\n"
            "        not-filter(|ops: occupation father>, |doctor> + |nurse>) rel-kets[*]\n"
            "            |John> + |Fred> + |Robert> + |Jack>\n\n"
            "    see also:\n"
            "        filter";

    operator_usage_map.map["apply"] =
            "\napply:\n"
            "    description:\n"
            "        apply(seq, seq)\n"
            "        wrapper around apply op\n\n"
            "    examples:\n"
            "        -- learn some knowledge\n"
            "        age |Fred> => |35>\n"
            "        nick-name |Fred> => |Freddie>\n"
            "        mother |Fred> => |Jude>\n"
            "        father |Fred> => |Tom>\n"
            "        age |Jude> => |61>\n\n"
            "        -- implements: age |Fred>\n"
            "        apply(|op: age>, |Fred>)\n"
            "            |35>\n\n"
            "        -- implements: age |Fred> + mother |Fred> + father |Fred>\n"
            "        apply(|op: age> + |op: mother> + |op: father>, |Fred>)\n"
            "            |35> + |Jude> + |Tom>\n\n"
            "        -- implements: age |Fred> . mother |Fred> . father |Fred>\n"
            "        apply(|op: age> . |op: mother> . |op: father>, |Fred>)\n"
            "            |35> . |Jude> . |Tom>\n\n"
            "        -- the star operator, which adds all the right hand rules together:\n"
            "        star |*> #=> apply(supported-ops|_self>, |_self>) |>\n\n"
            "        -- Eg, applied to Fred:\n"
            "        star |Fred>\n"
            "            |35> + |Freddie> + |Jude> + |Tom>\n\n"
            "        -- using an operator sequence instead:\n"
            "        -- implements: age mother |Fred>\n"
            "        apply(|ops: age mother>, |Fred>)\n"
            "            |61>\n\n"
            "    see also:\n"
            "        learn, add-learn, seq-learn";

    operator_usage_map.map["learn"] =
            "\nlearn:\n"
            "    description:\n"
            "        learn(sp, sp, seq)\n"
            "        wrapper around a learn rule\n\n"
            "    examples:\n"
            "        -- implements: age |Fred> => |37>\n"
            "        learn(|op: age>, |Fred>, |37>)\n\n"
            "    see also:\n"
            "         add-learn, seq-learn, apply";

    operator_usage_map.map["add-learn"] =
            "\nadd-learn:\n"
            "    description:\n"
            "        add-learn(sp, sp, seq)\n"
            "        wrapper around an add-learn rule\n\n"
            "    examples:\n"
            "        -- implements: friend |Fred> +=> |Sam>\n"
            "        -- implements: friend |Fred> +=> |Emma>\n"
            "        add-learn(|op: friend>, |Fred>, |Sam>)\n"
            "        add-learn(|op: friend>, |Fred>, |Emma>)\n\n"
            "    see also:\n"
            "         learn, seq-learn, apply";

    operator_usage_map.map["seq-learn"] =
            "\nseq-learn:\n"
            "    description:\n"
            "        seq-learn(sp, sp, seq)\n"
            "        wrapper around a seq-learn rule\n\n"
            "    examples:\n"
            "        -- implements: friend |Fred> .=> |Sam>\n"
            "        -- implements: friend |Fred> .=> |Emma>\n"
            "        seq-learn(|op: friend>, |Fred>, |Sam>)\n"
            "        seq-learn(|op: friend>, |Fred>, |Emma>)\n\n"
            "    see also:\n"
            "         learn, add-learn, apply";

    operator_usage_map.map["smerge"] =
            "\nsmerge:\n"
            "    description:\n"
            "        smerge seq\n"
            "        smerge[\"str\"] seq\n"
            "        merges a sequence into a single string, optionally separated by the str string\n\n"
            "    examples:\n"
            "        smerge (|F> . |r> . |e> . |d>)\n"
            "            |Fred>\n\n"
            "        smerge[\", \"] (|a> . |b> . |c> . |d>)\n"
            "            |a, b, c, d>\n\n"
            "        -- define the bracket operator:\n"
            "        bracket (*) #=> |[> _ smerge[\", \"] |__self> _ |]>\n\n"
            "        -- define the print-bracket operator:\n"
            "        print-bracket (*) #=> print bracket |__self>\n\n"
            "        -- quick test of the bracket operator:\n"
            "        bracket (|F> . |r> . |e> . |d>)\n"
            "            |[F, r, e, d]>\n\n"
            "        -- quick test of the print-bracket operator:\n"
            "        print-bracket (|F> . |r> . |e> . |d>)\n"
            "            [F, r, e, d]\n"
            "            |[F, r, e, d]>\n\n"
            "    see also:\n"
            "        ssplit, smap";

    operator_usage_map.map["learn-grid"] =
            "\nlearn-grid:\n"
            "    description:\n"
            "        learn-grid[width, height]\n"
            "        learn-grid[width, height, operator]\n"
            "        learn a grid of specified width and height\n"
            "        all cells initialized to zero, with respect to operator \"operator\"\n"
            "        if operator is not specified, use \"value\"\n"
            "        and we learn all direction operators, N, NE, E, SE, S, SW, W, NW, that don't point outside the grid\n\n"
            "    examples:\n"
            "        -- learn a sample grid:\n"
            "        learn-grid[2,2]\n"
            "        dump\n"
            "        ------------------------------------------\n"
            "        |context> => |Global context>\n"
            "\n"
            "        value |grid: 0: 0> => |0>\n"
            "        E |grid: 0: 0> => |grid: 0: 1>\n"
            "        SE |grid: 0: 0> => |grid: 1: 1>\n"
            "        S |grid: 0: 0> => |grid: 1: 0>\n"
            "\n"
            "        value |grid: 0: 1> => |0>\n"
            "        S |grid: 0: 1> => |grid: 1: 1>\n"
            "        SW |grid: 0: 1> => |grid: 1: 0>\n"
            "        W |grid: 0: 1> => |grid: 0: 0>\n"
            "\n"
            "        value |grid: 1: 0> => |0>\n"
            "        N |grid: 1: 0> => |grid: 0: 0>\n"
            "        NE |grid: 1: 0> => |grid: 0: 1>\n"
            "        E |grid: 1: 0> => |grid: 1: 1>\n"
            "\n"
            "        value |grid: 1: 1> => |0>\n"
            "        N |grid: 1: 1> => |grid: 0: 1>\n"
            "        W |grid: 1: 1> => |grid: 1: 0>\n"
            "        NW |grid: 1: 1> => |grid: 0: 0>\n"
            "        ------------------------------------------\n\n"
            "    see also:\n"
            "        display-grid";

    operator_usage_map.map["display-grid"] =
            "\ndisplay-grid:\n"
            "    description:\n"
            "        display-grid[width, height]\n"
            "        display-grid[width, height, operator]\n"
            "        display-grid[width, height, operator, empty-char]\n"
            "        display a rectangular map of the given width and height\n"
            "        where each cell is the value of \"operator\" applied to that cell (default operator is \"value\")\n"
            "        where empty-char is printed for cells with value 0 (default value of empty-char is \".\")\n\n"
            "    examples:\n"
            "        -- learn a small grid first:\n"
            "        learn-grid[9,5]\n\n"
            "        -- learn some cell values:\n"
            "        value |grid: 2: 2> => |H>\n"
            "        value |grid: 2: 3> => |e>\n"
            "        value |grid: 2: 4> => |l>\n"
            "        value |grid: 2: 5> => |l>\n"
            "        value |grid: 2: 6> => |o>\n\n"
            "        -- display the resulting grid:\n"
            "        display-grid[9, 5, value, \"*\"]\n"
            "            width:  9\n"
            "            height: 5\n"
            "\n"
            "            0      *   *   *   *   *   *   *   *   *\n"
            "            1      *   *   *   *   *   *   *   *   *\n"
            "            2      *   *   H   e   l   l   o   *   *\n"
            "            3      *   *   *   *   *   *   *   *   *\n"
            "            4      *   *   *   *   *   *   *   *   *\n\n"
            "    see also:\n"
            "        learn-grid";

    operator_usage_map.map["how-many"] =
            "\nhow-many:\n"
            "    description:\n"
            "        how-many sp\n"
            "        counts the number of kets in a superposition\n\n"
            "    examples:\n"
            "        how-many split |abcdef>\n"
            "            |number: 6>\n\n"
            "    see also:\n"
            "        measure-currency, show-many";

    operator_usage_map.map["show-many"] =
            "\nshow-many:\n"
            "    description:\n"
            "        show-many seq\n"
            "        counts the number of superpositions in a sequence\n\n"
            "    examples:\n"
            "        show-many ssplit |abcdef>\n"
            "            |number: 6>\n\n"
            "    see also:\n"
            "        how-many, measure-currency, how-many";

    operator_usage_map.map["measure-currency"] =
            "\nmeasure-currency:\n"
            "    description:\n"
            "        measure-currency sp\n"
            "        measures the \"currency\" used by a superposition\n"
            "        Ie, the sum of the coefficients of all the kets in the given superposition\n"
            "        If the superposition is \"clean\" then measure-currency is the same as the how-many operator\n\n"
            "    examples:\n"
            "        measure-currency (3|a> + 1.2|b> + 0.1|c>)\n"
            "            |number: 4.3>\n\n"
            "    see also:\n"
            "        how-many, show-many, clean";

    operator_usage_map.map["reverse"] =
            "\nreverse:\n"
            "    description:\n"
            "        reverse sp\n"
            "        reverse the given superposition\n\n"
            "    examples:\n"
            "        reverse (5.1|a> + 3.7|b> + |c> - 2.1|d>)\n"
            "            - 2.100000|d> + |c> + 3.700000|b> + 5.100000|a>\n\n"
            "    see also:\n"
            "        sreverse";

    operator_usage_map.map["sreverse"] =
            "\nsreverse:\n"
            "    description:\n"
            "        sreverse seq\n"
            "        reverse the given sequence\n\n"
            "    examples:\n"
            "        sreverse (5.1|a> . 3.7|b> . |c>)\n"
            "            |c> . 3.700000|b> . 5.100000|a>\n\n"
            "    see also:\n"
            "        reverse";

    operator_usage_map.map["sp2seq"] =
            "\nsp2seq:\n"
            "    description:\n"
            "        sp2seq sp\n"
            "        convert the given superposition into a sequence\n\n"
            "    examples:\n"
            "        sp2seq (|a> + |b> + |c>)\n"
            "            |a> . |b> . |c>\n\n"
            "    see also:\n"
            "        seq2sp";

    operator_usage_map.map["seq2sp"] =
            "\nseq2sp:\n"
            "    description:\n"
            "        seq2sp seq\n"
            "        convert the given sequence into a superposition\n\n"
            "    examples:\n"
            "        seq2sp (|a> . |b> . |c>)\n"
            "            |a> + |b> + |c>\n\n"
            "    see also:\n"
            "        sp2seq";

    operator_usage_map.map["plus"] =
            "\nplus:\n"
            "    description:\n"
            "        plus[n] ket\n"
            "        add n to the value in the ket, leaving the coefficient unchanged\n\n"
            "    examples:\n"
            "        plus[5] |3.1415>\n"
            "            |8.1415>\n\n"
            "    see also:\n"
            "        minus, times-by, divide-by, int-divide-by, mod, round";

    operator_usage_map.map["minus"] =
            "\nminus:\n"
            "    description:\n"
            "        minus[n] ket\n"
            "        subtract n from the value in the ket, leaving the coefficient unchanged\n\n"
            "    examples:\n"
            "        minus[2] |3.1415>\n"
            "            |1.1415>\n"
            "    see also:\n"
            "        plus, times-by, divide-by, int-divide-by, mod, round";

    operator_usage_map.map["times-by"] =
            "\ntimes-by:\n"
            "    description:\n"
            "        times-by[n] ket\n"
            "        times the value in the ket by n, leaving the coefficient unchanged\n\n"
            "    examples:\n"
            "        times-by[5] |6.1>\n"
            "            |30.5>\n\n"
            "    see also:\n"
            "        plus, minus, divide-by, int-divide-by, mod, round\n"
            "        temperature-conversion.sw3";

    operator_usage_map.map["divide-by"] =
            "\ndivide-by:\n"
            "    description:\n"
            "        divide-by[n] ket\n"
            "        divide the value in the ket by n, leaving the coefficient unchanged\n\n"
            "    examples:\n"
            "        divide-by[5] |625.5>\n"
            "            |125.1>\n\n"
            "    see also:\n"
            "        plus, minus, times-by, int-divide-by, mod, round";

    operator_usage_map.map["int-divide-by"] =
            "\nint-divide-by:\n"
            "    description:\n"
            "        int-divide-by[n] ket\n"
            "        integer divide the value in the ket by n, leaving the coefficient unchanged\n\n"
            "    examples:\n"
            "        int-divide-by[1000] |123456>\n"
            "            |123>\n\n"
            "    see also:\n"
            "        plus, minus, times-by, divide-by, mod, round";

    operator_usage_map.map["mod"] =
            "\nmod:\n"
            "    description:\n"
            "        mod[n] ket\n"
            "        apply mod n to the value in the ket by n, leaving the coefficient unchanged\n\n"
            "    examples:\n"
            "        mod[1000] |1234567>\n"
            "            |567>\n\n"
            "    see also:\n"
            "        plus, minus, times-by, divide-by, int-divide-by, round";

    operator_usage_map.map["round"] =
            "\nround:\n"
            "    description:\n"
            "        round[n] ket\n"
            "        round the value in the ket to n places, leaving the coefficient unchanged\n"
            "        If you need more decimal places in your kets, use the --places command line option.\n"
            "        The default is currently set to 5\n\n"
            "    examples:\n"
            "        round[3] |3.14159>\n"
            "            |3.142>\n\n"
            "    see also:\n"
            "        plus, minus, times-by, divide-by, int-divide-by, mod";

    operator_usage_map.map["to-upper"] =
            "\nto-upper:\n"
            "    description:\n"
            "        to-upper ket\n"
            "        set all characters to upper case\n\n"
            "        to-upper[i1, i2, ..., in] ket\n"
            "        change i'th characters to upper case\n\n"
            "    examples:\n"
            "        to-upper |fred>\n"
            "            |FRED>\n\n"
            "        to-upper[1] |fred>\n"
            "            |Fred>\n\n"
            "        to-upper[1,3,5] |abcdefg>\n"
            "            |AbCdEfg>\n\n"
            "    see also:\n"
            "        to-lower";

    operator_usage_map.map["to-lower"] =
            "\nto-lower:\n"
            "    description:\n"
            "        to-lower ket\n"
            "        set all characters to lower case\n\n"
            "        to-lower[i1, i2, ..., in] ket\n"
            "        change i'th characters to lower case\n\n"
            "    examples:\n"
            "        to-lower |FRED>\n"
            "            |fred>\n\n"
            "        to-lower[1] |FRED>\n"
            "            |fRED>\n\n"
            "        to-lower[1,3,5] |ABCDEFG>\n"
            "            |aBcDeFG>\n\n"
            "    see also:\n"
            "        to-upper";

    operator_usage_map.map["split"] =
            "\nsplit:\n"
            "    description:\n"
            "        split ket\n"
            "        splits the ket into a superposition\n\n"
            "        split[\"str\"] ket\n"
            "        splits the ket into a superposition, splitting on str\n\n"
            "    examples:\n"
            "        split |abcde>\n"
            "            |a> + |b> + |c> + |d> + |e>\n\n"
            "        split[\"d\"] |abcdef>\n"
            "            |abc> + |ef>\n\n"
            "        split[\"g\"] split[\"d\"] |abcdefghij>\n"
            "            |abc> + |ef> + |hij>\n\n"
            "    see also:\n"
            "        ssplit";

    operator_usage_map.map["ssplit"] =
            "\nssplit:\n"
            "    description:\n"
            "        ssplit ket\n"
            "        splits the ket into a sequence\n\n"
            "        ssplit[\"str\"] ket\n"
            "        splits the ket into a sequence, splitting on str\n\n"
            "    examples:\n"
            "        ssplit |abcde>\n"
            "            |a> . |b> . |c> . |d> . |e>\n\n"
            "        ssplit[\", \"] |a, b, c>\n"
            "            |a> . |b> . |c>\n\n"
            "        ssplit[\" and \"] |a, b, c and d>\n"
            "            |a, b, c> . |d>\n\n"
            "        ssplit[\", \"] ssplit[\" and \"] |a, b, c and d>\n"
            "            |a> . |b> . |c> . |d>\n\n"
            "    see also:\n"
            "        split, smerge";

    operator_usage_map.map["extract-category"] =
            "\nextract-category:\n"
            "    description:\n"
            "        extract-category ket\n"
            "        extract the \"category\" from the given ket\n"
            "        categories are separated by \": \"\n"
            "        with the most general category on the left, and the most specific on the right\n"
            "        for example |animal: mammal: dog>\n"
            "        has the most general category \"animal\", then the category \"mammal\" and then finally the \"value\" dog\n"
            "        categories can be considered a type for the object\n"
            "        Eg, |word: house> says house is a type of word\n"
            "        and |food: apple> says apple is a type of food\n"
            "        and we can define operators with respect to them\n"
            "        Eg, op |food: *> #=> ...\n"
            "        will define \"op\" with respect to all objects of type\\category \"food\".\n\n"
            "    examples:\n"
            "        -- if there is no category, then return the empty ket:\n"
            "        -- NB: this is in contrast to the python version of the Semantic DB which would instead return |dog>\n"
            "        extract-category |dog>\n"
            "            |>\n\n"
            "        -- remove the \"value\" from the ket:\n"
            "        -- in other words, extract the category of the ket\n"
            "        extract-category |animal: mammal: dog>\n"
            "            |animal: mammal>\n\n"
            "        -- remove the \"value\" from the ket, and then the most specific \"category\":\n"
            "        extract-category extract-category |animal: mammal: dog>\n"
            "            |animal>\n\n"
            "        -- or using the powered-operator notation:\n"
            "        extract-category^2 |animal: mammal: dog>\n"
            "            |animal>\n\n"
            "        -- an abstract example:\n"
            "        extract-category |a: b: c: d: e: f>\n"
            "            |a: b: c: d: e>\n\n"
            "    see also:\n"
            "        extract-value, extract-head, extract-tail";

    operator_usage_map.map["extract-value"] =
            "\nextract-value:\n"
            "    description:\n"
            "        extract-value ket\n"
            "        extract the value, ie, remove the category, from the given ket\n"
            "        categories are separated by \": \"\n"
            "        with the most general category on the left, and the most specific on the right\n"
            "        for example |animal: mammal: dog>\n"
            "        has the most general category \"animal\", then the category \"mammal\" and then finally the \"value\" dog\n"
            "        categories can be considered a type for the object\n"
            "        and values are specific examples of that type\n"
            "        Eg, |food: apple> says apple is a type of food, and the value of |food: apple> is apple\n\n"
            "    examples:\n"
            "        -- if there is no category, then return unchanged:\n"
            "        extract-value |dog>\n"
            "            |dog>\n\n"
            "        extract-value |animal: mammal: dog>\n"
            "            |dog>\n\n"
            "        -- an abstract example:\n"
            "        extract-value |a: b: c: d: e: f>\n"
            "            |f>\n\n"
            "    see also:\n"
            "        extract-category, extract-head, extract-tail";

    operator_usage_map.map["extract-head"] =
            "\nextract-head:\n"
            "    description:\n"
            "        extract-head ket\n"
            "        categories are separated by \": \"\n"
            "        with the most general category on the left, and the most specific on the right\n"
            "        for example |animal: mammal: dog>\n"
            "        has the most general category \"animal\", then the category \"mammal\" and then finally the \"value\" dog\n"
            "        This list of categories and the value can be considered a type of list\n"
            "        extract-head returns the first element, or head, of this list\n\n"
            "    examples:\n"
            "        -- if there is no category, then return unchanged:\n"
            "        extract-head |dog>\n"
            "            |dog>\n\n"
            "        extract-head |animal: mammal: dog>\n"
            "            |animal>\n\n"
            "        -- an abstract example:\n"
            "        extract-head |a: b: c: d: e: f>\n"
            "            |a>\n\n"
            "    see also:\n"
            "        extract-category, extract-value, extract-tail";

    operator_usage_map.map["extract-tail"] =
            "\nextract-tail:\n"
            "    description:\n"
            "        extract-tail ket\n"
            "        categories are separated by \": \"\n"
            "        with the most general category on the left, and the most specific on the right\n"
            "        for example |animal: mammal: dog>\n"
            "        has the most general category \"animal\", then the category \"mammal\" and then finally the \"value\" dog\n"
            "        This list of categories and the value can be considered a type of list\n"
            "        extract-tail returns the tail of this list\n"
            "        Ie, with the first category removed\n\n"
            "    examples:\n"
            "        -- if there is no category, then return the empty ket:\n"
            "        extract-tail |dog>\n"
            "            |>\n\n"
            "        extract-tail |animal: mammal: dog>\n"
            "            |mammal: dog>\n\n"
            "        -- an abstract example:\n"
            "        extract-tail |a: b: c: d: e: f>\n"
            "            |b: c: d: e: f>\n\n"
            "    see also:\n"
            "        extract-category, extract-value, extract-head";

    operator_usage_map.map["print"] =
            "\nprint:\n"
            "    description:\n"
            "        print ket\n"
            "        print the given ket to standard out, appending a new line\n"
            "        often used with the infix operators _ and __ which join ket labels, where __ inserts an extra space\n"
            "        also frequently used with the smerge[] operator\n"
            "        print returns the input ket, so it can be chained with other operators\n\n"
            "    examples:\n"
            "        print |Just a short sentence.>\n"
            "            Just a short sentence.\n"
            "            |Just a short sentence.>\n"
            "        print (|A> __ |short> __ |example> _ |.>)\n"
            "            A short example.\n"
            "            |A short example.>\n\n"
            "        print smerge[\", \"] (|a> . |b> . |c>)\n"
            "            a, b, c\n"
            "            |a, b, c>\n\n"
            "    see also:\n"
            "        to-upper, to-lower, smerge";

    operator_usage_map.map["threshold-filter"] =
            "\nthreshold-filter:\n"
            "    description:\n"
            "        threshold-filter[t] ket\n"
            "        if x < t, return 0, else return x\n"
            "        combined with drop, eg: drop threshold-filter[t] sp\n"
            "        filter the given superposition to only those with coefficients >= t.\n\n"
            "    examples:\n"
            "        threshold-filter[2] (3|a> + 2.2|b> - 3 |c> + |d>)\n"
            "            3|a> + 2.200000|b> + 0|c> + 0|d>\n\n"
            "        drop threshold-filter[2] (3|a> + 2.2|b> - 3 |c> + |d>)\n"
            "            3|a> + 2.200000|b>\n\n"
            "    see also:\n"
            "        not-threshold-filter";

    operator_usage_map.map["not-threshold-filter"] =
            "\nnot-threshold-filter:\n"
            "    description:\n"
            "        not-threshold-filter[t] ket\n"
            "        if x <= t, return x, else return 0\n\n"
            "    examples:\n"
            "        not-threshold-filter[2] (3|a> + 2.2|b> - 3 |c> + |d>)\n"
            "            0|a> + 0|b> - 3|c> + |d>\n\n"
            "    see also:\n"
            "        threshold-filter";

    operator_usage_map.map["sigmoid-in-range"] =
            "\nsigmoid-in-range:\n"
            "    description:\n"
            "        sigmoid-in-range[a, b] ket\n"
            "        if a <= x <= b, return x, else return 0\n\n"
            "    examples:\n"
            "        sigmoid-in-range[2,4] (|a> + 2|b> + 3|c> + 4|d> + 5|e>)\n"
            "            0|a> + 2|b> + 3|c> + 4|d> + 0|e>\n\n"
            "    see also:\n"
            "        threshold-filter";

    operator_usage_map.map["op-zip"] =
            "\nop-zip:\n"
            "    description:\n"
            "        op-zip(seq) input-seq\n"
            "        zip together a sequence of operators with a sequence of superpositions (given by input-seq)\n"
            "        stops at the shorter of the two sequences\n"
            "        NB: it is invoked slightly differently from the python version\n"
            "        where it was: op-zip(seq, seq)\n\n"
            "    examples:\n"
            "        -- define some for-example operators:\n"
            "        -- but keep it abstract for now:\n"
            "        op1 (*) #=> |op1:> __ |__self>\n"
            "        op2 (*) #=> |op2:> __ |__self>\n"
            "        op3 (*) #=> |op3:> __ |__self>\n\n"
            "        -- define the corresponding operator sequence:\n"
            "        op |seq> => |op: op1> . |op: op2> . |op: op3>\n\n"
            "        -- define a for-example sequence, again, just something abstract:\n"
            "        the |input seq> => |a> . |b> . |c> . |d> . |e>\n\n"
            "        -- now apply it:\n"
            "        op-zip(op |seq>) the |input seq>\n"
            "            |op1: a> . |op2: b> . |op3: c>\n\n"
            "    see also:\n"
            "        numbers-to-words.sw3";

    operator_usage_map.map["if"] =
            "\nif:\n"
            "    description:\n"
            "        if(condition, operator1, operator2) input-seq\n"
            "        if condition evaluates to |yes> or |true> then apply operator1 to input-seq\n"
            "        else apply operator2 to input-seq\n"
            "        NB: the python version of if() is much uglier and clunkier.\n\n"
            "    examples:\n"
            "        -- just define a couple of abstract operators:\n"
            "        op1 (*) #=> |op1:> __ smerge[\", \"] |__self>\n"
            "        op2 (*) #=> |op2:> __ smerge[\", \"] |__self>\n\n"
            "        -- then apply it:\n"
            "        if(|yes>, |op: op1>, |op: op2>) ssplit |abc>\n"
            "            |op1: a, b, c>\n\n"
            "        if(|no>, |op: op1>, |op: op2>) ssplit |abc>\n"
            "            |op2: a, b, c>\n\n"
            "    see also:\n"
            "        value-if\n";

    operator_usage_map.map["value-if"] =
            "\nvalue-if:\n"
            "    description:\n"
            "        value-if(condition, seq1, seq2) input-seq\n"
            "        if condition evaluates to |yes> or |true> then return seq1, else return seq2\n"
            "        input-seq is ignored\n\n"
            "    examples:\n"
            "        value-if( |yes>, |branch a>, |branch b>)\n"
            "            |branch a>\n\n"
            "        value-if( |no>, |branch a>, |branch b>)\n"
            "            |branch b>\n\n"
            "    see also:\n"
            "        if\n";

    operator_usage_map.map["is-less-than"] =
            "\nis-less-than:\n"
            "    description:\n"
            "        is-less-than[value] ket\n"
            "        returns yes/no if the value in ket < value\n\n"
            "    examples:\n"
            "        is-less-than[1000] |987>\n"
            "            |yes>\n\n"
            "        is-less-than[80] |age: 76>\n"
            "            |yes>\n\n"
            "        is-less-than[2000] |year: 2018>\n"
            "            |no>\n\n"
            "        -- if the ket has no float value then return the empty ket |>\n"
            "        is-less-than[13] |the cat>\n"
            "            |>\n\n"
            "    see also:\n"
            "        is-less-equal-than, is-equal, is-greater-than, is-greater-equal-than, is-in-range";

    operator_usage_map.map["is-less-equal-than"] =
            "\nis-less-equal-than:\n"
            "    description:\n"
            "        is-less-equal-than[value] ket\n"
            "        returns yes/no if the value in ket <= value\n\n"
            "    examples:\n"
            "        is-less-equal-than[80] |age: 76>\n"
            "            |yes>\n\n"
            "        is-less-equal-than[2010] |year: 2010>\n"
            "            |yes>\n\n"
            "        -- if the ket has no float value then return the empty ket |>\n"
            "        is-less-equal-than[13] |the cat>\n"
            "            |>\n\n"
            "    see also:\n"
            "        is-less-than, is-equal, is-greater-than, is-greater-equal-than, is-in-range";

    operator_usage_map.map["is-equal"] =
            "\nis-equal:\n"
            "    description:\n"
            "        is-equal[value] ket\n"
            "        returns yes/no if the value in ket == value\n\n"
            "    examples:\n"
            "        is-equal[80] |age: 76>\n"
            "            |no>\n\n"
            "        is-equal[2010] |year: 2010>\n"
            "            |yes>\n\n"
            "        -- if the ket has no float value then return the empty ket |>\n"
            "        is-equal[13] |the cat>\n"
            "            |>\n\n"
            "    see also:\n"
            "        is-less-than, is-less-equal-than, is-greater-than, is-greater-equal-than, is-in-range\n\n"
            "\nis-equal:\n"
            "    description:\n"
            "        is-equal(one, two)\n"
            "        returns |yes> if one == two, else |no>\n"
            "        where one and two are sequences\n"
            "        the order of the kets in any of the superpositions does not matter\n"
            "        however, the order of the superpositions in the sequences do matter\n"
            "        NB: if one and two are both the empty ket, return |no>\n\n"
            "    examples:\n"
            "        -- Let's give some abstract examples:\n\n"
            "        -- first demonstrate it works with superpositions\n"
            "        -- and note order of kets in superpositions does not matter:\n"
            "        sp |one> => rank split |abcd>\n"
            "        sp |two> => shuffle sp |one>\n"
            "        is-equal(sp |one>, sp |two>)\n"
            "            |yes>\n\n"
            "        -- now demonstrate it works with sequences:\n"
            "        seq |one> => rank split |abcd> . rank split |efg> . rank split |hijkl>\n"
            "        seq |two> => shuffle seq |one>\n"
            "        is-equal(seq |one>, seq |two>)\n"
            "            |yes>\n\n"
            "        -- now show that the order of the superpositions in the sequences DO matter:\n"
            "        seq |three> => sshuffle seq |one>\n"
            "        is-equal(seq |one>, seq |three>)\n"
            "            |no>\n\n"
            "    see also:\n"
            "        simm, strict-simm, rank, split, shuffle, sshuffle";

    operator_usage_map.map["is-greater-than"] =
            "\nis-greater-than:\n"
            "    description:\n"
            "        is-greater-than[value] ket\n"
            "        returns yes/no if the value in ket > value\n\n"
            "    examples:\n"
            "        is-greater-than[5] |7>\n"
            "            |yes>\n\n"
            "        is-greater-than[3] |price: 3.50>\n"
            "            |yes>\n\n"
            "        is-greater-than[26] |number: 25>\n"
            "            |no>\n\n"
            "        -- if the ket has no float value then return the empty ket |>\n"
            "        is-greater-than[13] |the cat>\n"
            "            |>\n\n"
            "    see also:\n"
            "        is-less-than, is-less-equal-than, is-equal, is-greater-equal-than, is-in-range";

    operator_usage_map.map["is-greater-equal-than"] =
            "\nis-greater-equal-than:\n"
            "    description:\n"
            "        is-greater-equal-than[value] ket\n"
            "        returns yes/no if the value in ket >= value\n\n"
            "    examples:\n"
            "        is-greater-equal-than[13] |number: 13>\n"
            "            |yes>\n\n"
            "        is-greater-equal-than[21] |age: 23>\n"
            "            |yes>\n\n"
            "        is-greater-equal-than[1980] |year: 1977>\n"
            "            |no>\n\n"
            "        -- if the ket has no float value then return the empty ket |>\n"
            "        is-greater-equal-than[13] |the cat>\n"
            "            |>\n\n"
            "    see also:\n"
            "        is-greater-than, is-less-than, is-less-equal-than, is-equal, is-in-range";

    operator_usage_map.map["is-in-range"] =
            "\nis-in-range:\n"
            "    description:\n"
            "        is-in-range[value1, value2] ket\n"
            "        returns yes/no if value1 <= the value in ket <= value2\n\n"
            "    examples:\n"
            "        is-in-range[2,4] ssplit |0123456>\n"
            "            |no> . |no> . |yes> . |yes> . |yes> . |no> . |no>\n\n"
            "        not |yes> => |no>\n"
            "        not |no> => |yes>\n"
            "        is-a-child |*> #=> is-in-range[0,17] age |_self>\n"
            "        is-a-teenager |*> #=> is-in-range[13,19] age |_self>\n"
            "        is-an-adult |*> #=> not is-in-range[0,17] age |_self>\n"
            "        age |Emma> => |14>\n"
            "        age |Bella> => |18>\n"
            "        age |Fred> => |34>\n\n"
            "        table[person, age, is-a-child, is-a-teenager, is-an-adult] split[\" \"] |Emma Bella Fred>\n"
            "            +--------+-----+------------+---------------+-------------+\n"
            "            | person | age | is-a-child | is-a-teenager | is-an-adult |\n"
            "            +--------+-----+------------+---------------+-------------+\n"
            "            | Emma   | 14  | yes        | yes           | no          |\n"
            "            | Bella  | 18  | no         | yes           | yes         |\n"
            "            | Fred   | 34  | no         | no            | yes         |\n"
            "            +--------+-----+------------+---------------+-------------+\n\n"
            "        -- if the ket has no float value then return the empty ket |>\n"
            "        is-in-range[13, 17] |the cat>\n"
            "            |>\n\n"
            "    see also:\n"
            "        is-less-than, is-less-equal-than, is-equal, is-greater-than, is-greater-equal-than";

    operator_usage_map.map["is-prime"] =
            "\nis-prime:\n"
            "    description:\n"
            "        is-prime ket\n"
            "        return |yes> or |no> if the given ket is prime or not\n\n"
            "    examples:\n"
            "        is-prime |379721>\n"
            "            |yes>\n"
            "    see also:\n"
            "        prime-factors";

    operator_usage_map.map["prime-factors"] =
            "\nprime-factors:\n"
            "    description:\n"
            "        prime-factors ket\n"
            "        returns a list/superposition of prime factors\n\n"
            "    examples:\n"
            "        prime-factors |987654321>\n"
            "            2|3> + 2|17> + |379721>\n\n"
            "        prime-factors |number: 123456789>\n"
            "            2|number: 3> + |number: 3607> + |number: 3803>\n\n"
            "    see also:\n"
            "        is-prime";

    operator_usage_map.map["such-that"] =
            "\nsuch-that:\n"
            "    description:\n"
            "        such-that[op] seq\n"
            "        filters the given sequence to those elements that return |yes> or |true> for op applied to that element\n"
            "        it is less powerful than filter() but on the other hand, it should be faster\n\n"
            "    examples:\n"
            "        is-hungry |Fred> => |no>\n"
            "        is-hungry |Sam> => |yes>\n"
            "        is-hungry |Emma> => |yes>\n"
            "        is-hungry |Liz> => |no>\n"
            "        such-that[is-hungry] rel-kets[*]\n"
            "            |Sam> + |Emma>\n\n"
            "        such-that[is-prime] srange(|1>, |20>)\n"
            "            |2> . |3> . |5> . |7> . |11> . |13> . |17> . |19>\n\n"
            "    see also:\n"
            "        filter";

    operator_usage_map.map["is-mbr"] =
            "\nis-mbr:\n"
            "    description:\n"
            "        is-mbr(ket) seq\n"
            "        returns |yes> if ket is in seq, else |no>\n"
            "        just a standard, set membership test\n"
            "        ie, is the given ket a member of the given set represented by seq\n\n"
            "    examples:\n"
            "        is-mbr(|b>) split |abc>\n"
            "            |yes>\n\n"
            "        is-mbr(|c>) (0.3|a> + 2|b> + 9.7|c> + 13|d>)\n"
            "            |yes>\n\n"
            "        is-mbr(|x>) (0.3|a> + 2|b> + 9.7|c> + 13|d>)\n"
            "            |no>\n\n"
            "        friends |Fred> => |Jack> + |Harry> + |Ed> + |Mary> + |Rob> + |Patrick> + |Emma> + |Charlie>\n\n"
            "        -- is Ed one of Fred's friends?\n"
            "        is-mbr(|Ed>) friends |Fred>\n"
            "            |yes>\n\n"
            "        -- is Jane one of Fred's friends?\n"
            "        is-mbr(|Jane>) friends |Fred>\n"
            "            |no>\n\n"
            "    see also:\n"
            "        is-subset, union, intersection";

    operator_usage_map.map["mbr"] =
            "\nmbr:\n"
            "    description:\n"
            "        mbr(ket) sp\n"
            "        returns the coeff of ket in the given superposition\n"
            "        if ket is not in the sp then the returned coeff is 0\n\n"
            "    examples:\n"
            "        mbr(|b>) (|a> + |b> + |c>)\n"
            "            |b>\n\n"
            "        mbr(|c>) (0.3|a> + 2|b> + 9.7|c> + 13|d>)\n"
            "            9.700000|c>\n\n"
            "        mbr(|x>) (0.3|a> + 2|b> + 9.7|c> + 13|d>)\n"
            "            0|x>\n\n"
            "    see also:\n"
            "        is-mbr";

    operator_usage_map.map["is-subset"] =
            "\nis-subset:\n"
            "    description:\n"
            "        is-subset(seq) input-seq\n"
            "        returns |yes> if seq is a \"subset\" of input-seq, else |no>\n"
            "        where subset means: for all kets in seq, they have value <= the value in input-seq\n"
            "        it generalizes the idea of sets and their subsets, since it allows elements to have corresponding coefficients\n"
            "        so for example: asking if {a,c} is a subset of {a,b,c,d,e}\n"
            "        is equivalent to: is-subset(|a> + |c>) (|a> + |b> + |c> + |d> + |e>)\n"
            "        or more compactly: is-subset(split |ac>) split |abcde>\n"
            "        this extends the notion that sets can be represented by \"clean\" superpositions\n"
            "        and non-clean superpositions represent fuzzy sets\n"
            "        where \"clean\" means all coefficients of kets are either 0 or 1\n\n"
            "    examples:\n"
            "        is-subset(|b>) split |abc>\n"
            "            |yes>\n\n"
            "        is-subset(split |bd>) split |abc>\n"
            "            |no>\n\n"
            "        -- note, the order of the elements in the superpositions do not matter:\n"
            "        is-subset(8|c> + 13|d> + 0.2|a>) (0.3|a> + 2|b> + 9.7|c> + 13|d>)\n"
            "            |yes>\n\n"
            "        friends |Fred> => |Sam> + |Emma> + |Rob> + |Liz> + |Harold> + |Tom>\n"
            "        friends |Sam> => |Emma> + |Tom> + |Liz>\n"
            "        friends |Harold> => |Rob> + |Liz> + |Tom> + |Beth>\n\n"
            "        -- are Sam's friends a subset of Fred's friends?\n"
            "        is-subset(friends |Sam>) friends |Fred>\n"
            "            |yes>\n\n"
            "        -- are Harold's friends a subset of Fred's friends?\n"
            "        is-subset(friends |Harold>) friends |Fred>\n"
            "            |no>\n\n"
            "    see also:\n"
            "        is-mbr, union, intersection";

    operator_usage_map.map["smap"] =
            "\nsmap:\n"
            "    description:\n"
            "        smap[min, max, op] seq\n"
            "        smap(min, max, op) seq\n"
            "        partition seq into ngrams of size ranging from min to max, then apply op to those ngrams\n"
            "        in the background, we have a variable that keeps track of the current position in the sequence:\n"
            "        the |smap pos>\n"
            "        NB: the indexing for the smap position starts from 1 not 0.\n\n"
            "    examples:\n"
            "        -- just an abstract test:\n"
            "        bracket (*) #=> |[> _ smerge[\", \"] |__self> _ |]>\n"
            "        print-bracket (*) #=> print bracket |__self>\n"
            "        print-smap-bracket (*) #=> print (the |smap pos> _ |:> __ bracket |__self>)\n\n"
            "        -- the constant parameter version:\n"
            "        smap[1, 4, print-smap-bracket] ssplit |abcdef>\n"
            "            1: [a]\n"
            "            2: [b]\n"
            "            3: [c]\n"
            "            4: [d]\n"
            "            5: [e]\n"
            "            6: [f]\n"
            "            2: [a, b]\n"
            "            3: [b, c]\n"
            "            4: [c, d]\n"
            "            5: [d, e]\n"
            "            6: [e, f]\n"
            "            3: [a, b, c]\n"
            "            4: [b, c, d]\n"
            "            5: [c, d, e]\n"
            "            6: [d, e, f]\n"
            "            4: [a, b, c, d]\n"
            "            5: [b, c, d, e]\n"
            "            6: [c, d, e, f]\n\n"
            "        -- the variable parameter version:\n"
            "        -- probably a little slower, but more flexible\n"
            "        smap(|1>, |4>, |op: print-smap-bracket>) ssplit |abcdef>\n\n"
            "    see also:\n";

    operator_usage_map.map["Gaussian"] =
            "\nGaussian:\n"
            "    description:\n"
            "        Gaussian[sigma] ket\n"
            "        Gaussian[sigma, dx] ket\n"
            "        implements a Gaussian superposition centred on ket, with sigma the standard deviation\n"
            "        if dx is not specified, it defaults to 1, where dx is step size\n\n"
            "    the algorithm:\n"
            "        exp( - ED(x, y) / (2 * sigma ^ 2))\n"
            "        where ED(x, y) is the Euclidean distance between x and y\n\n"
            "    examples:\n"
            "        Gaussian[0.7] |40>\n"
            "            0.016880|36> + 0.046830|37> + 0.129923|38> + 0.360448|39> + |40> + 0.360448|41> + 0.129923|42> + 0.046830|43> + 0.016880|44>\n\n"
            "        -- bar-chart of 1D version:\n"
            "        bar-chart[50] Gaussian[0.7] |age: 35>\n"
            "            ----------\n"
            "            age: 31 : |\n"
            "            age: 32 : ||\n"
            "            age: 33 : ||||||\n"
            "            age: 34 : ||||||||||||||||||\n"
            "            age: 35 : ||||||||||||||||||||||||||||||||||||||||||||||||||\n"
            "            age: 36 : ||||||||||||||||||\n"
            "            age: 37 : ||||||\n"
            "            age: 38 : ||\n"
            "            age: 39 : |\n"
            "            ----------\n\n"
            "        -- 2D version:\n"
            "        Gaussian[0.5] |10: 10>\n"
            "            0.003493|8: 8> + 0.011423|8: 9> + 0.018316|8: 10> + 0.011423|8: 11> + 0.003493|8: 12> + 0.011423|9: 8> + 0.059106|9: 9> + 0.135335|9: 10> + 0.059106|9: 11> + 0.011423|9: 12> + 0.018316|10: 8> + 0.135335|10: 9> + |10: 10> + 0.135335|10: 11> + 0.018316|10: 12> + 0.011423|11: 8> + 0.059106|11: 9> + 0.135335|11: 10> + 0.059106|11: 11> + 0.011423|11: 12> + 0.003493|12: 8> + 0.011423|12: 9> + 0.018316|12: 10> + 0.011423|12: 11> + 0.003493|12: 12>\n\n"
            "    see also:\n";

    operator_usage_map.map["and"] =
            "\nand:\n"
            "    description:\n"
            "        and(ket1, ket2)\n"
            "        returns |yes> if ket1 and ket2 are |yes>, |no> otherwise.\n\n"
            "    examples:\n"
            "        and(|yes>, |yes>)\n"
            "            |yes>\n\n"
            "        and(|yes>, |no>)\n"
            "            |no>\n\n"
            "        and(|no>, |no>)\n"
            "            |no>\n\n"
            "    see also:\n"
            "        or, xor\n"
            "\nand:\n"
            "    description:\n"
            "        and(ket) input-seq\n"
            "        applies and(ket, x) for each x in input-seq\n"
            "        as such, it preserves input-seq structure\n"
            "        but, because it preserves input-seq structure, it is slower than the above version.\n\n"
            "    examples:\n"
            "        and(|yes>) (|no> . |yes>)\n"
            "            |no> . |yes>\n\n"
            "    see also:\n"
            "        or, xor";

    operator_usage_map.map["or"] =
            "\nor:\n"
            "    description:\n"
            "        or(ket1, ket2)\n"
            "        returns |yes> if ket1 or ket2 are |yes>, |no> otherwise.\n\n"
            "    examples:\n"
            "        or(|yes>, |yes>)\n"
            "            |yes>\n\n"
            "        or(|yes>, |no>)\n"
            "            |yes>\n\n"
            "        or(|no>, |no>)\n"
            "            |no>\n\n"
            "    see also:\n"
            "        and, xor\n"
            "\nor:\n"
            "    description:\n"
            "        or(ket) input-seq\n"
            "        applies or(ket, x) for each x in input-seq\n"
            "        as such, it preserves input-seq structure\n"
            "        but, because it preserves input-seq structure, it is slower than the above version.\n\n"
            "    examples:\n"
            "        or(|yes>) (|no> . |yes>)\n"
            "            |yes> . |yes>\n\n"
            "        or(|no>) (|no> . |yes>)\n"
            "            |no> . |yes>\n\n"
            "    see also:\n"
            "        and, xor";

    operator_usage_map.map["xor"] =
            "\nxor:\n"
            "    description:\n"
            "        xor(ket1, ket2)\n"
            "        returns |yes> if ket1 xor ket2 are |yes>, |no> otherwise.\n\n"
            "    examples:\n"
            "        xor(|yes>, |yes>)\n"
            "            |no>\n\n"
            "        xor(|yes>, |no>)\n"
            "            |yes>\n\n"
            "        xor(|no>, |no>)\n"
            "            |no>\n\n"
            "    see also:\n"
            "        and, or\n"
            "\nxor:\n"
            "    description:\n"
            "        xor(ket) input-seq\n"
            "        applies xor(ket, x) for each x in input-seq\n"
            "        as such, it preserves input-seq structure\n"
            "        but, because it preserves input-seq structure, it is slower than the above version.\n\n"
            "    examples:\n"
            "        xor(|yes>) (|no> . |yes>)\n"
            "            |yes> . |no>\n\n"
            "        xor(|no>) (|no> . |yes>)\n"
            "            |no> . |yes>\n\n"
            "    see also:\n"
            "        and, or";

    operator_usage_map.map["find-inverse"] =
            "\nfind-inverse:\n"
            "    description:\n"
            "        find-inverse[op1, op2, ...]\n"
            "        find-inverse[*]\n"
            "        learn the inverses for the given operators\n"
            "        since operators are directed links in a graph, we use this function to learn the inverse links\n\n"
            "    examples:\n"
            "        load fred-sam-friends.sw\n"
            "        find-inverse[friends]\n"
            "        dump\n"
            "            ------------------------------------------\n"
            "            |context> => |Fred Sam friends>\n"
            "\n"
            "            friends |Fred> => |Jack> + |Harry> + |Ed> + |Mary> + |Rob> + |Patrick> + |Emma> + |Charlie>\n"
            "            age |Fred> => |32>\n"
            "\n"
            "            friends |Sam> => |Charlie> + |George> + |Emma> + |Jack> + |Robert> + |Frank> + |Julie>\n"
            "            age |Sam> => |34>\n"
            "\n"
            "            inverse-friends |Jack> => |Fred> + |Sam>\n"
            "\n"
            "            inverse-friends |Harry> => |Fred>\n"
            "\n"
            "            inverse-friends |Ed> => |Fred>\n"
            "\n"
            "            inverse-friends |Mary> => |Fred>\n"
            "\n"
            "            inverse-friends |Rob> => |Fred>\n"
            "\n"
            "            inverse-friends |Patrick> => |Fred>\n"
            "\n"
            "            inverse-friends |Emma> => |Fred> + |Sam>\n"
            "\n"
            "            inverse-friends |Charlie> => |Fred> + |Sam>\n"
            "\n"
            "            inverse-friends |George> => |Sam>\n"
            "\n"
            "            inverse-friends |Robert> => |Sam>\n"
            "\n"
            "            inverse-friends |Frank> => |Sam>\n"
            "\n"
            "            inverse-friends |Julie> => |Sam>\n"
            "            ------------------------------------------\n\n"
            "    see also:\n";

    operator_usage_map.map["has-suffix"] =
            "\nhas-suffix:\n"
            "    description:\n"
            "        has-suffix[\"str\"] ket\n"
            "        returns |yes> if the ket has the given suffix\n\n"
            "    examples:\n"
            "        has-suffix[\"day\"] |Tuesday>\n"
            "            |yes>\n\n"
            "        has-suffix[\"str\"] |Tuesday>\n"
            "            |no>\n"
            "    see also:\n"
            "        has-prefix, remove-suffix, remove-prefix";

    operator_usage_map.map["remove-suffix"] =
            "\nremove-suffix:\n"
            "    description:\n"
            "        remove-suffix[\"str\"] ket\n"
            "        if ket has suffix str then remove it\n\n"
            "    examples:\n"
            "        remove-suffix[\"day\"] |Tuesday>\n"
            "            |Tues>\n\n"
            "        remove-suffix[\"str\"] |Tuesday>\n"
            "            |Tuesday>\n\n"
            "    see also:\n"
            "        remove-prefix, has-suffix, has-prefix";

    operator_usage_map.map["has-prefix"] =
            "\nhas-prefix:\n"
            "    description:\n"
            "        has-prefix[\"str\"] ket\n"
            "        returns |yes> if the ket has the given prefix\n\n"
            "    examples:\n"
            "        has-prefix[\"not \"] |not sitting at the beach>\n"
            "            |yes>\n\n"
            "        has-prefix[\"not \"] |sitting at the beach>\n"
            "            |no>\n\n"
            "    see also:\n"
            "        has-suffix, remove-suffix, remove-prefix";

    operator_usage_map.map["remove-prefix"] =
            "\nremove-prefix:\n"
            "    description:\n"
            "        remove-prefix[\"str\"] ket\n"
            "        if ket has prefix str then remove it\n\n"
            "    examples:\n"
            "        remove-prefix[\"not \"] |not sitting at the beach>\n"
            "            |sitting at the beach>\n\n"
            "        remove-prefix[\"word: \"] |word: table>\n"
            "            |table>\n\n"
            "        remove-prefix[\"food: \"] |word: chair>\n"
            "            |word: chair>\n\n"
            "    see also:\n"
            "        remove-suffix, has-suffix, has-prefix";

    operator_usage_map.map["to-comma-number"] =
            "\nto-comma-number:\n"
            "    description:\n"
            "        to-comma-number ket\n"
            "        insert thousands commas into numbers\n\n"
            "    examples:\n"
            "        to-comma-number |8825>\n"
            "            |8,825>\n\n"
            "        to-comma-number |population: 2300000>\n"
            "            |population: 2,300,000>\n\n"
            "        to-comma-number |km: 22956.53>\n"
            "            |km: 22,956.53>\n\n"
            "    see also:\n"
            "        table, round";

    operator_usage_map.map["union"] =
            "\nunion:\n"
            "    description:\n"
            "        union(seq, seq)\n"
            "        the union function, takes element-wise max of the coefficients\n"
            "        it generalizes standard set union where the coefficients are either 0 or 1\n"
            "        ie, it is a fuzzy set union\n\n"
            "    examples:\n"
            "        -- set union of {a,b,c,d} and {b,d,e,f,g}:\n"
            "        union(split |abcd>, split |bdefg>)\n"
            "            |a> + |b> + |c> + |d> + |e> + |f> + |g>\n\n"
            "        -- fuzzy set union example:\n"
            "        union(3|a> + 1.2|b>, 3.5|a> + 0.9|b> + 5.13|c>)\n"
            "            3.500000|a> + 1.200000|b> + 5.130000|c>\n\n"
            "        -- sequence union example:\n"
            "        union( ssplit |abcde>, ssplit |xyz>)\n"
            "            |a> + |x> . |b> + |y> . |c> + |z> . |d> . |e>\n\n"
            "    see also:\n"
            "        intersection, sum, is-subset, is-mbr, simm\n";

    operator_usage_map.map["intersection"] =
            "\nintersection:\n"
            "    description:\n"
            "        intersection(seq, seq)\n"
            "        the intersection function, takes element-wise min of the coefficients\n"
            "        it generalizes standard set intersection where the coefficients are either 0 or 1\n"
            "        ie, it is a fuzzy set intersection\n\n"
            "    examples:\n"
            "        -- set intersection of {a,b,c,d} and {b,d,e,f,g}:\n"
            "        intersection(split |abcd>, split |bdefg>)\n"
            "            |b> + |d>\n\n"
            "        -- fuzzy set intersection example:\n"
            "        intersection(3|a> + 1.2|b>, 3.5|a> + 0.9|b> + 5.13|c>)\n"
            "            3|a> + 0.900000|b>\n\n"
            "        -- sequence intersection example:\n"
            "        intersection( ssplit |abcde>, ssplit |abc>)\n"
            "            |a> . |b> . |c>\n\n"
            "    see also:\n"
            "        union, sum, is-subset, is-mbr, simm";

    operator_usage_map.map["sum"] =
            "\nsum:\n"
            "    description:\n"
            "        sum(seq, seq)\n"
            "        the sum function, takes element-wise sum of the coefficients\n\n"
            "    examples:\n"
            "        -- sequence sum example:\n"
            "        sum( ssplit |abcdefg>, ssplit |abxyz>)\n"
            "            2|a> . 2|b> . |c> + |x> . |d> + |y> . |e> + |z> . |f> . |g>\n\n"
            "    see also:\n"
            "        intersection, union, is-subset, is-mbr, simm\n";

    operator_usage_map.map["select"] =
            "\nselect:\n"
            "    description:\n"
            "        select[k1, k2] sp\n"
            "        select the k1'th to the k2'th elements from the given superposition\n"
            "        indices start from 1, not 0\n"
            "        also, final element has index -1, 2nd last element -2, and so on.\n\n"
            "    examples:\n"
            "        select[2, 4] split |abcdefg>\n"
            "            |b> + |c> + |d>\n\n"
            "        select[-3, -1] split |abcdefg>\n"
            "            |e> + |f> + |g>\n\n"
            "    see also:\n"
            "        sselect";

    operator_usage_map.map["sselect"] =
            "\nsselect:\n"
            "    description:\n"
            "        sselect[k1, k2] seq\n"
            "        select the k1'th to the k2'th elements from the given sequence\n"
            "        indices start from 1, not 0\n"
            "        also, final element has index -1, 2nd last element -2, and so on.\n\n"
            "    examples:\n"
            "        sselect[2, 4] ssplit |abcdefg>\n"
            "            |b> . |c> . |d>\n\n"
            "        sselect[-3, -1] ssplit |abcdefg>\n"
            "            |e> . |f> . |g>\n\n"
            "    see also:\n"
            "        select";

    operator_usage_map.map["find-path-between"] =
            "\nfind-path-between:\n"
            "    description:\n"
            "        find-path-between(ket1, ket2)\n"
            "        Use Dijkstra's algorithm to find the shortest path between ket1 and ket2\n"
            "        See: https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm\n"
            "        To instead find the operators required to get from ket1 to ket2 see find-operators-between().\n\n"
            "    examples:\n"
            "        -- learn a grid, then find a path:\n"
            "        learn-grid[10, 10]\n"
            "        find-path-between(|grid: 0: 0>, |grid: 5: 5>)\n"
            "            |grid: 0: 0> . |grid: 1: 1> . |grid: 2: 2> . |grid: 3: 3> . |grid: 4: 4> . |grid: 5: 5>\n\n"
            "    see also:\n"
            "        find-operators-between";

    operator_usage_map.map["find-operators-between"] =
            "\nfind-operators-between:\n"
            "    description:\n"
            "        find-operators-between(ket1, ket2)\n"
            "        Use Dijkstra's algorithm to find the shortest path between ket1 and ket2\n"
            "        See: https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm\n"
            "        Same as find-path-between(), except we instead return the operator sequence required to get from ket1 to ket2\n\n"
            "    examples:\n"
            "        -- learn a grid, then find a path:\n"
            "        learn-grid[10, 10]\n"
            "        find-operators-between(|grid: 0: 0>, |grid: 5: 6>)\n"
            "            |op: E> . |op: SE> . |op: SE> . |op: SE> . |op: SE> . |op: SE>\n\n"
            "        -- a quick demonstration that this is correct:\n"
            "        SE SE SE SE SE E |grid: 0: 0>\n"
            "            |grid: 5: 6>\n\n\n"
            "        -- find pathway through a friend network:\n"
            "        -- first define some friends:\n"
            "        friends |Fred> => |Jack> + |Harry> + |Ed> + |Mary> + |Rob> + |Patrick> + |Emma> + |Charlie>\n"
            "        friends |Sam> => |Charlie> + |George> + |Emma> + |Jack> + |Robert> + |Frank> + |Julie>\n\n"
            "        -- find inverse friends links:\n"
            "        find-inverse[friends]\n\n"
            "        -- find friend pathway from Fred to Sam:\n"
            "        find-operators-between(|Fred>, |Sam>)\n"
            "            |op: friends> . |op: inverse-friends>\n\n"
            "        -- find friend pathway from Fred to Julie:\n"
            "        find-operators-between(|Fred>, |Julie>)\n"
            "            |op: friends> . |op: inverse-friends> . |op: friends>\n\n"
            "        -- verify we reach Julie using this operator sequence:\n"
            "        friends inverse-friends friends |Fred>\n"
            "            11|Jack> + 8|Harry> + 8|Ed> + 8|Mary> + 8|Rob> + 8|Patrick> + 11|Emma> + 11|Charlie> + 3|George> + 3|Robert> + 3|Frank> + 3|Julie>\n\n"
            "    see also:\n"
            "        find-path-between, find-inverse";

    operator_usage_map.map["unlearn"] =
            "\nunlearn:\n"
            "    description:\n"
            "        unlearn[op1, op2, ..., opn] sp\n"
            "        unlearn[*] sp\n"
            "        unlearn the given operator(s) for all the kets in sp\n"
            "        if * is used, then unlearn all supported operators, ie, everything\n"
            "        In some cases where an object has a lot of learn rules, it could be slow\n\n"
            "    examples:\n"
            "        -- load some toy knowledge:\n"
            "        load fred-sam-friends.sw3\n\n"
            "        -- see what we know:\n"
            "        dump verbose\n"
            "            ------------------------------------------\n"
            "            |context> => |Fred Sam friends>\n\n"
            "            supported-ops |Fred> => |op: friends> + |op: age>\n"
            "            friends |Fred> => |Jack> + |Harry> + |Ed> + |Mary> + |Rob> + |Patrick> + |Emma> + |Charlie>\n"
            "            age |Fred> => |32>\n\n"
            "            supported-ops |Sam> => |op: friends> + |op: age>\n"
            "            friends |Sam> => |Charlie> + |George> + |Emma> + |Jack> + |Robert> + |Frank> + |Julie>\n"
            "            age |Sam> => |34>\n"
            "            ------------------------------------------\n\n"
            "        -- now delete the age operator for Fred:\n"
            "        unlearn[age] |Fred>\n\n"
            "        -- see what we now know:\n"
            "        dump verbose\n"
            "            ------------------------------------------\n"
            "            |context> => |Fred Sam friends>\n\n"
            "            supported-ops |Fred> => |op: friends>\n"
            "            friends |Fred> => |Jack> + |Harry> + |Ed> + |Mary> + |Rob> + |Patrick> + |Emma> + |Charlie>\n\n"
            "            supported-ops |Sam> => |op: friends> + |op: age>\n"
            "            friends |Sam> => |Charlie> + |George> + |Emma> + |Jack> + |Robert> + |Frank> + |Julie>\n"
            "            age |Sam> => |34>\n"
            "            ------------------------------------------\n\n"
            "        -- now delete the friends operator for Fred:\n"
            "        unlearn[friends] |fred>\n\n"
            "        -- see what we now know:\n"
            "        dump verbose\n"
            "            ------------------------------------------\n"
            "            |context> => |Fred Sam friends>\n\n"
            "            supported-ops |Fred> => |>\n\n"
            "            supported-ops |Sam> => |op: friends> + |op: age>\n"
            "            friends |Sam> => |Charlie> + |George> + |Emma> + |Jack> + |Robert> + |Frank> + |Julie>\n"
            "            age |Sam> => |34>\n"
            "            ------------------------------------------\n\n"
            "    see also:\n";

    operator_usage_map.map["sshuffle"] =
            "\nsshuffle:\n"
            "    description:\n"
            "        sshuffle seq\n"
            "        randomly shuffle the input sequence\n\n"
            "    examples:\n"
            "        sshuffle (|one> . |two> . |three> . |four> . |five>)\n"
            "            |two> . |four> . |five> . |three> . |one>\n\n"
            "    see also:\n"
            "        shuffle";

    operator_usage_map.map["shuffle"] =
            "\nshuffle:\n"
            "    description:\n"
            "        shuffle seq\n"
            "        randomly shuffle each superposition in the input sequence\n\n"
            "    examples:\n"
            "        shuffle (|one> + |two> + |three> + |four> + |five> . |x> + |y> + |z>)\n"
            "            |one> + |four> + |two> + |three> + |five> . |z> + |x> + |y>\n\n"
            "    see also:\n"
            "        sshuffle";

    operator_usage_map.map["sidx"] =
            "\nsidx:\n"
            "    description:\n"
            "        sidx input-seq\n"
            "        map superpositions in a sequence to their index number\n"
            "        NB: counting starts from 1 not 0\n"
            "        The original use case for this operator failed, so may delete this operator in the future\n\n"
            "    examples:\n"
            "        sidx (|a> . |b> . |c> . |d> . |e>)\n"
            "            |1> . |2> . |3> . |4> . |5>\n\n"
            "    see also:\n";

    operator_usage_map.map["srotate-left"] =
            "\nsrotate-left:\n"
            "    description:\n"
            "        srotate-left input-seq\n"
            "        rotate the input sequence left one step\n\n"
            "        srotate-left[n] input-seq\n"
            "        rotate the input sequence left n steps, modulus size(input-seq)\n\n"
            "    examples:\n"
            "        srotate-left (|one> . |two> . |three> . |four> . |five>)\n"
            "            |two> . |three> . |four> . |five> . |one>\n\n"
            "        srotate-left[3] (|one> . |two> . |three> . |four> . |five>)\n"
            "            |four> . |five> . |one> . |two> . |three>\n\n"
            "        -- 11 mod 5 == 1, so rotate left 1 step:\n"
            "        srotate-left[11] (|one> . |two> . |three> . |four> . |five>)\n"
            "            |two> . |three> . |four> . |five> . |one>\n\n"
            "    see also:\n"
            "        srotate-right, rotate-right, rotate-left";

    operator_usage_map.map["srotate-right"] =
            "\nsrotate-right:\n"
            "    description:\n"
            "        srotate-right input-seq\n"
            "        rotate the input sequence right one step\n\n"
            "        srotate-right[n] input-seq\n"
            "        rotate the input sequence right n steps, modulus size(input-seq)\n\n"
            "    examples:\n"
            "        srotate-right (|one> . |two> . |three> . |four> . |five>)\n"
            "            |five> . |one> . |two> . |three> . |four>\n\n"
            "        srotate-right[3] (|one> . |two> . |three> . |four> . |five>)\n"
            "            |three> . |four> . |five> . |one> . |two>\n\n"
            "        -- 11 mod 5 == 1, so rotate right 1 step:\n"
            "        srotate-right[11] (|one> . |two> . |three> . |four> . |five>)\n"
            "            |five> . |one> . |two> . |three> . |four>\n\n"
            "    see also:\n"
            "        srotate-left, rotate-right, rotate-left";

    operator_usage_map.map["rotate-right"] =
            "\nrotate-right:\n"
            "    description:\n"
            "        rotate-right input-seq\n"
            "        rotate each superposition in input-seq right by 1 step\n\n"
            "        rotate-right[n] input-seq\n"
            "        rotate each superposition in input-seq right by n steps, modulus by the size of the corresponding superposition\n\n"
            "    examples:\n"
            "        rotate-right (|one> + |two> + |three> + |four> + |five> + |six> + |seven>)\n"
            "            |seven> + |one> + |two> + |three> + |four> + |five> + |six>\n\n"
            "        rotate-right[3] (|one> + |two> + |three> + |four> + |five> + |six> + |seven>)\n"
            "            |five> + |six> + |seven> + |one> + |two> + |three> + |four>\n\n"
            "    see also:\n"
            "        rotate-left, srotate-right, srotate-left";

    operator_usage_map.map["rotate-left"] =
            "\nrotate-left:\n"
            "    description:\n"
            "        rotate-left input-seq\n"
            "        rotate each superposition in input-seq left by 1 step\n\n"
            "        rotate-left[n] input-seq\n"
            "        rotate each superposition in input-seq left by n steps, modulus by the size of the corresponding superposition\n\n"
            "    examples:\n"
            "        rotate-left (|one> + |two> + |three> + |four> + |five> + |six> + |seven>)\n"
            "            |two> + |three> + |four> + |five> + |six> + |seven> + |one>\n\n"
            "        rotate-left[3] (|one> + |two> + |three> + |four> + |five> + |six> + |seven>)\n"
            "            |four> + |five> + |six> + |seven> + |one> + |two> + |three>\n\n"
            "    see also:\n"
            "        rotate-right, srotate-right, srotate-left";

    operator_usage_map.map["sread"] =
            "\nsread:\n"
            "    description:\n"
            "        sread(positions) input-seq\n"
            "        replace positions with their index in the input sequence\n"
            "        we try to preserve the 'structure' of 'positions'\n"
            "        index values start from 1, not 0\n"
            "        negative values are also valid, so -1 is last element, -2 is second last element, etc\n"
            "        if out of range, or not a number, return |> for that slot\n\n"
            "    examples:\n"
            "        -- preserve superposition structure of 'positions':\n"
            "        sread(|1> + |3> + |5>) (|one> . |two> . |three> . |four> . |five> . |six> . |seven>)\n"
            "            |one> + |three> + |five>\n\n"
            "        -- preserve sequence structure of 'positions':\n"
            "        sread(|1> . |3> . |5>) (|one> . |two> . |three> . |four> . |five> . |six> . |seven>)\n"
            "            |one> . |three> . |five>\n\n"
            "        -- handle negative indices:\n"
            "        sread(|-1> . |-2> . |-3>) (|one> . |two> . |three> . |four> . |five> . |six> . |seven>)\n"
            "            |seven> . |six> . |five>\n\n"
            "        -- if out of range, or not a number, return |> for that slot:\n"
            "        sread(|1> . |fish> . |11> . |4>) (|one> . |two> . |three> . |four> . |five> . |six> . |seven>)\n"
            "            |one> . |> . |> . |four>\n\n"
            "    see also:\n"
            "        not-sread";

    operator_usage_map.map["not-sread"] =
            "\nnot-sread:\n"
            "    description:\n"
            "        not-sread(positions) input-seq\n"
            "        remove superpositions from the input sequence if they are in 'positions'\n"
            "        index values start from 1, not 0\n"
            "        negative values are also valid, so -1 is last element, -2 is second last element, etc\n"
            "        if out of range, then ignore that index value\n"
            "        'positions' can be a superposition or a sequence, it doesn't matter\n"
            "        if it is a sequence, it is converted to a superposition anyway\n"
            "        the order of the indices in 'positions' is ignored, since they are inserted into a set\n\n"
            "    examples:\n"
            "        -- remove the 1st, 3rd and 5th superpositions from the input sequence:\n"
            "        not-sread(|1> + |3> + |5>) (|one> . |two> . |three> . |four> . |five> . |six> . |seven>)\n"
            "            |two> . |four> . |six> . |seven>\n\n"
            "        -- remove the 2nd last, and the 4th last superpositions from the input sequence:\n"
            "        not-sread(|-2> + |-4>) (|one> . |two> . |three> . |four> . |five> . |six> . |seven>)\n"
            "            |one> . |two> . |three> . |five> . |seven>\n\n"
            "    see also:\n"
            "        sread";

    operator_usage_map.map["pick"] =
            "\npick:\n"
            "    description:\n"
            "        pick[n] input-seq\n"
            "        randomly pick n elements from each superposition in the input sequence\n"
            "        if n is greater than the size of the superposition, then only return size(superposition) elements\n"
            "        if n is less than or equal 0, return the empty ket\n\n"
            "    examples:\n"
            "        -- randomly pick three elements from the given superposition:\n"
            "        pick[3] (|one> + |two> + |three> + |four> + |five> + |six> + |seven>)\n"
            "            |three> + |seven> + |four>\n\n"
            "    see also:\n"
            "        pick-elt, weighted-pick-elt";

    operator_usage_map.map["scompress"] =
            "\nscompress:\n"
            "    description:\n"
            "        scompress[source-op, dest-op]\n"
            "        scompress[source-op, dest-op, \"str\"]\n"
            "        scompress[source-op, dest-op, \"str\", min-ngram-len, max-ngram-len]\n"
            "        reads in all the patterns that are defined with respect to 'source-op'\n"
            "        then breaks those patterns into smaller and smaller ngrams\n"
            "        counting the frequency of those ngrams\n"
            "        for a given ngram size, the first, most common, ngram is then promoted to its own pattern\n"
            "        repeat, until ngram size is 1\n"
            "        then save all the new patterns with respect to the 'dest-op' operator\n"
            "        If \"str\" is given, use that instead of \"scompress: \".\n\n"
            "    examples:\n"
            "        -- learn a couple of simple sequences, that have shared 'ngram structure':\n"
            "        seq |one> => |A> . |B> . |C> . |D> . |E> . |F>\n"
            "        seq |two> => |G> . |B> . |C> . |H> . |B> . |C> . |D> . |X> . |Y>\n\n"
            "        -- in this case we have shared ngrams: |B> . |C> . |D> and |B> . |C>\n\n"
            "        -- now run the operator:\n"
            "        scompress[seq, new-seq]\n\n"
            "        -- now dump the results:\n"
            "        dump\n"
            "            ------------------------------------------\n"
            "            |context> => |Global context>\n"
            "\n"
            "            seq |one> => |A> . |B> . |C> . |D> . |E> . |F>\n"
            "            new-seq |one> => |A> . |scompress: 0> . |E> . |F>\n"
            "\n"
            "            seq |two> => |G> . |B> . |C> . |H> . |B> . |C> . |D> . |X> . |Y>\n"
            "            new-seq |two> => |G> . |scompress: 1> . |H> . |scompress: 0> . |X> . |Y>\n"
            "\n"
            "            new-seq |scompress: 1> => |B> . |C>\n"
            "\n"
            "            new-seq |scompress: 0> => |scompress: 1> . |D>\n"
            "\n"
            "            new-seq |*> #=> |_self>\n"
            "            ------------------------------------------\n\n"
            "        -- We can then recover the original sequences using: 'dest-op^k'\n"
            "        -- where k is in some sense a measure of the depth of the hierarchy of the system.\n\n"
            "        -- Let's demonstrate:\n"
            "        new-seq |one>\n"
            "            |A> . |scompress: 0> . |E> . |F>\n\n"
            "        new-seq^2 |one>\n"
            "            |A> . |scompress: 1> . |D> . |E> . |F>\n\n"
            "        new-seq^3 |one>\n"
            "            |A> . |B> . |C> . |D> . |E> . |F>\n\n\n"
            "        new-seq |two>\n"
            "            |G> . |scompress: 1> . |H> . |scompress: 0> . |X> . |Y>\n\n"
            "        new-seq^2 |two>\n"
            "            |G> . |B> . |C> . |H> . |scompress: 1> . |D> . |X> . |Y>\n\n"
            "        new-seq^3 |two>\n"
            "            |G> . |B> . |C> . |H> . |B> . |C> . |D> . |X> . |Y>\n\n"
            "        -- And in this case we see we recover the original sequences when k is 3.\n"
            "        -- So that is the hierarchical depth of this system.\n\n"
            "    see also:\n";

    operator_usage_map.map["starts-with"] =
            "\nstarts-with:\n"
            "    description:\n"
            "        starts-with |prefix>\n"
            "        returns all known kets that starts-with the prefix \"prefix\"\n\n"
            "    examples:\n"
            "        -- eg, find people with a given first name:\n"
            "        -- learn some people:\n"
            "        first-name |Fred Smith> => |Fred>\n"
            "        last-name |Fred Roberts> => |Roberts>\n"
            "        middle-name |Sam J. Gleeson> => |Jack>\n"
            "        age |Sam O'Conner> => |age: 47>\n"
            "        mother |Sam Tompson> => |Liz Tompson>\n\n"
            "        -- now find all kets that starts-with |Fred >\n"
            "        starts-with |Fred >\n"
            "            |Fred Smith> + |Fred Roberts>\n\n"
            "        -- now find all kets that starts-with |Sam >\n"
            "        starts-with |Sam >\n"
            "            |Sam J. Gleeson> + |Sam O'Conner> + |Sam Tompson>\n\n"
            "    see also:\n"
            "        rel-kets\n";

    operator_usage_map.map["string-replace"] =
            "\nstring-replace:\n"
            "    description:\n"
            "        string-replace(source-sp, dest-ket) input-seq\n"
            "        For all kets in source-sp, replace with dest-ket in input-seq\n\n"
            "    examples:\n"
            "        string-replace(|sad>, |happy>) (|a> . |sad> . |fellow>)\n"
            "            |a> . |happy> . |fellow>\n\n\n"
            "        -- remove \" chars operator:\n"
            "        remove-quotes (*) #=> string-replace(|\">, |>) |__self>\n\n"
            "        -- now put it to use:\n"
            "        remove-quotes |text: \"some text\">\n"
            "            |text: some text>\n\n\n"
            "        -- remove punctuation chars:\n"
            "        -- :;.,!?$-\"'\n"
            "        remove-punctuation (*) #=> string-replace(split |:;.,!?$-\"'>, |>) |__self>\n\n"
            "        -- now put it to use:\n"
            "        remove-punctuation |some !$??..,:\"text>\n"
            "            |some text>\n\n"
            "    see also:\n"
            "        char-replace\n";

    operator_usage_map.map["inherit"] =
            "\ninherit:\n"
            "    description:\n"
            "        inherit[parent-type, op] input-seq\n"
            "        inherit the given operator from the given parent-type\n"
            "        We also try our best to maintain the \"structure\" of input-seq\n\n"
            "    examples:\n"
            "        -- learn the parent types for an old cat named trudy:\n"
            "        parent-type |trudy> => |cat>\n"
            "        parent-type |cat> => |feline>\n"
            "        parent-type |feline> => |mammal>\n"
            "        parent-type |mammal> => |animal>\n\n"
            "        -- learn some features from parent types:\n"
            "        has-fur |animal> => |yes>\n"
            "        has-teeth |animal> => |yes>\n"
            "        has-pointy-ears |feline> => |yes>\n\n"
            "        -- Trudy is an old cat, so has no teeth left:\n"
            "        has-teeth |trudy> => |no>\n\n"
            "        -- now, we can ask some questions:\n"
            "        -- does trudy have pointy ears? Which we expect to inherit from feline\n"
            "        inherit[parent-type, has-pointy-ears] |trudy>\n"
            "            |yes>\n\n"
            "        -- does trudy have fur? Which we expect to inherit from animal\n"
            "        inherit[parent-type, has-fur] |trudy>\n"
            "            |yes>\n\n"
            "        -- does trudy have teeth? Which we inherit from animal, but is over-ridden by trudy:\n"
            "        inherit[parent-type, has-teeth] |trudy>\n"
            "            |no>\n\n"
            "        -- now, learn some info about a dog called rex:\n"
            "        parent-type |rex> => |dog>\n"
            "        parent-type |dog> => |canine>\n"
            "        parent-type |canine> => |mammal>\n\n"
            "        -- we already know the parent type of mammal is an animal\n\n"
            "        -- do trudy and rex have teeth?\n"
            "        inherit[parent-type, has-teeth] (|trudy> + |rex>)\n"
            "            |no> + |yes>\n\n"
            "    see also:\n"
            "        inherit-path\n";

    operator_usage_map.map["inherit-path"] =
            "\ninherit-path:\n"
            "    description:\n"
            "        inherit-path[parent-type] input-seq\n"
            "        return the inherit path for the kets in input-seq\n\n"
            "    examples:\n"
            "        -- learn some inheritance paths:\n"
            "        parent-type |trudy> => |cat>\n"
            "        parent-type |cat> => |feline>\n"
            "        parent-type |feline> => |mammal>\n"
            "        parent-type |mammal> => |animal>\n\n"
            "        parent-type |rex> => |dog>\n"
            "        parent-type |dog> => |canine>\n"
            "        parent-type |canine> => |mammal>\n\n"
            "        -- now find the inheritance path for trudy and rex:\n"
            "        inherit-path[parent-type] (|trudy> + |rex>)\n"
            "            |animal: mammal: feline: cat: trudy> + |animal: mammal: canine: dog: rex>\n\n"
            "    see also:\n"
            "        inherit, extract-value, extract-category";

    operator_usage_map.map["sprint"] =
            "\nsprint:\n"
            "    description:\n"
            "        sprint input-seq\n"
            "        sprint[\"prefix\"] input-seq\n"
            "        sprint[\"prefix\", \"suffix\"] input-seq\n"
            "        print the input sequence\n"
            "        if prefix and suffix are defined, then print them out too\n\n"
            "    examples:\n"
            "        sprint ssplit |ABCDEF>\n"
            "            |A> . |B> . |C> . |D> . |E> . |F>\n\n"
            "        sprint[\"pre: \", \" :post\"] ssplit |ABCD>\n"
            "            pre: |A> . |B> . |C> . |D> :post\n\n"
            "    see also:\n"
            "        print\n";

    operator_usage_map.map["sort-by"] =
            "\nsort-by:\n"
            "    description:\n"
            "        sort-by[op] input-seq\n"
            "        sort the superpositions in input-seq with respect to op applied to the kets in those superpositions\n\n"
            "    examples:\n"
            "        -- learn some knowledge:\n"
            "        age |Fred> => |47>\n"
            "        age |Sam> => |43>\n"
            "        age |Rob> => |29>\n"
            "        age |Emma> => |26>\n\n"
            "        -- now sort them:\n"
            "        sort-by[age] split[\" \"] |Rob Sam Emma Fred>\n"
            "            |Emma> + |Rob> + |Sam> + |Fred>\n\n"
            "    see also:\n"
            "        ket-sort, coeff-sort, natural-sort, ket-length\n";

    operator_usage_map.map["ket-length"] =
            "\nket-length:\n"
            "    description:\n"
            "        ket-length input-seq\n"
            "        Maps each ket in input-seq to its size\n\n"
            "    examples:\n"
            "        ket-length (|apple> + |orange> + |fish>)\n"
            "            |number: 5> + |number: 6> + |number: 4>\n\n"
            "    see also:\n"
            "        how-many, show-many, sort-by\n";

    operator_usage_map.map["compile"] =
            "\ncompile:\n"
            "    description:\n"
            "        compile input-seq\n"
            "        unpack the input-seq and compile the result\n"
            "        the first superposition is the operator name\n"
            "        the rest are parameters to be fed to that operator\n"
            "        NB: the parameters are only superpositions, not sequences\n"
            "        If you require sequence parameters, then you need to do it indirectly using a wrapper function\n\n"
            "    examples:\n"
            "        -- define a function, then compile it:\n"
            "        fn (*,*,*) #=> 2|__self0> . 3|__self1> . 5|__self2> . 7|__self3>\n"
            "        compile (|op: fn> . |input> . |a> . |b> . |c>)\n"
            "            2|input> . 3|a> . 5|b> . 7|c>\n\n"
            "        -- Now, if you require sequence parameters, you need a wrapper function:\n"
            "        wrapper-fn (*,*,*) #=> fn(seq |__self1>, seq |__self2>, seq |__self3>) seq |__self0>\n\n"
            "        -- Then we define our sequence parameters\n"
            "        -- They can be anything:\n"
            "        seq |input> => |input seq>\n"
            "        seq |a> => |seq 1>\n"
            "        seq |b> => |seq 2>\n"
            "        seq |c> => |seq 3>\n\n"
            "        -- Now, compile it:\n"
            "        compile (|op: wrapper-fn> . |input> . |a> . |b> . |c>)\n"
            "            2|input seq> . 3|seq 1> . 5|seq 2> . 7|seq 3>\n\n"
            "    see also:\n"
            "        apply\n";

    operator_usage_map.map["for"] =
            "\nfor:\n"
            "    description:\n"
            "        for(fn, sp)\n"
            "        for(fn, sp1, sp2)\n"
            "        for(fn, sp1, sp2, sp3)\n"
            "        apply fn to each of the kets in the given superpositions, using a Cartesian product\n"
            "        NB: if given sequences, they are first cast to superpositions\n"
            "        If you want to use sequences, use sfor() instead\n\n"
            "    examples:\n"
            "        -- for loop over single parameter function:\n"
            "        fn (*) #=> |fn:> __ |__self>\n"
            "        for( |op: fn>, split |abcde>)\n"
            "            |fn: a> + |fn: b> + |fn: c> + |fn: d> + |fn: e>\n\n"
            "        -- for loop over two parameter function:\n"
            "        fn2 (*,*) #=> |fn2(> _ |__self1> _ |, > _ |__self2> _ |)>\n"
            "        for( |op: fn2>, split |abc>, split |xyz>)\n"
            "            |fn2(a, x)> + |fn2(a, y)> + |fn2(a, z)> + |fn2(b, x)> + |fn2(b, y)> + |fn2(b, z)> + |fn2(c, x)> + |fn2(c, y)> + |fn2(c, z)>\n\n"
            "        -- for loop over three parameter function:\n"
            "        fn3 (*,*,*) #=> |fn2(> _ |__self1> _ |, > _ |__self2> _ |, > _ |__self3> _ |)>\n"
            "        for( |op: fn3>, split |ab>, split |uv>, split |xy>)\n"
            "            |fn2(a, u, x)> + |fn2(a, u, y)> + |fn2(a, v, x)> + |fn2(a, v, y)> + |fn2(b, u, x)> + |fn2(b, u, y)> + |fn2(b, v, x)> + |fn2(b, v, y)>\n\n"
            "    see also:\n"
            "        sfor\n";

    operator_usage_map.map["sfor"] =
            "\nsfor:\n"
            "    description:\n"
            "        sfor(fn, seq)\n"
            "        sfor(fn, seq1, seq2)\n"
            "        sfor(fn, seq1, seq2, seq3)\n"
            "        apply fn to each of the superpositions in the given sequences, using a Cartesian product\n\n"
            "    examples:\n"
            "        -- for loop over single parameter function:\n"
            "        fn (*) #=> |fn(> _ smerge[\", \"] |__self> _ |)>\n"
            "        sfor( |op: fn>, split (|abc> . |de> . |xyz>))\n"
            "            |fn(a, b, c)> . |fn(d, e)> . |fn(x, y, z)>\n\n"
            "    see also:\n"
            "        for\n";

    operator_usage_map.map["hash"] =
            "\nhash:\n"
            "    description:\n"
            "        hash[b] input-seq\n"
            "        hash each ket in input-seq, but only keep b bits of the result\n"
            "        NB: it is a standard c++ hash, and is not cryptographically secure\n"
            "        Note, sequence structure is preserved\n\n"
            "    examples:\n"
            "        -- compress a range of values into a smaller range:\n"
            "        hash[2] seq2sp srange(|1>, |10>)\n"
            "            3|3> + 2|2> + 2|1> + 3|0>\n\n"
            "        -- it also preserves sequence structure:\n"
            "        hash[2] srange(|11>, |15>)\n"
            "            |2> . |3> . |0> . |2> . |2>\n\n"
            "        -- and of course, works for any type of ket label:\n"
            "        hash[8] ssplit[\" \"] |Monday Tuesday Wednesday Thursday Friday Saturday Sunday>\n"
            "            |40> . |154> . |60> . |225> . |18> . |33> . |8>\n\n"
            "    see also:\n";

    operator_usage_map.map["common"] =
            "\ncommon:\n"
            "    description:\n"
            "        common[op] seq\n"
            "        find the intersection of op applied to each of the kets in seq\n"
            "        while trying to preserve sequence structure\n\n"
            "    examples:\n"
            "    -- learn Fred and Sam friends:\n"
            "    friends |Fred> => |Jack> + |Harry> + |Ed> + |Mary> + |Rob> + |Patrick> + |Emma> + |Charlie>\n"
            "    friends |Sam> => |Charlie> + |George> + |Emma> + |Jack> + |Robert> + |Frank> + |Julie>\n\n"
            "    -- find their common friends:\n"
            "    common[friends] split[\" \"] |Fred Sam>\n"
            "        |Jack> + |Emma> + |Charlie>\n\n"
            "    see also:\n"
            "        op-union, op-sum\n";

    operator_usage_map.map["op-union"] =
            "\nop-union:\n"
            "    description:\n"
            "        op-union[op] seq\n"
            "        find the union of op applied to each of the kets in seq\n"
            "        while trying to preserve sequence structure\n\n"
            "    examples:\n"
            "        -- learn some toy knowledge:\n"
            "        days |weekday> => split[\" \"] |Monday Tuesday Wednesday Thursday Friday>\n"
            "        days |weekend> => split[\" \"] |Saturday Sunday>\n\n"
            "        -- now find their union:\n"
            "        op-union[days] split[\" \"] |weekday weekend>\n"
            "            |Monday> + |Tuesday> + |Wednesday> + |Thursday> + |Friday> + |Saturday> + |Sunday>\n\n"
            "    see also:\n"
            "        common, op-sum\n";

    operator_usage_map.map["op-sum"] =
            "\nop-sum:\n"
            "    description:\n"
            "        op-sum[op] seq\n"
            "        find the sum of op applied to each of the kets in seq\n"
            "        while trying to preserve sequence structure\n\n"
            "    examples:\n"
            "        seq |one> => ssplit |abcde>\n"
            "        seq |two> => ssplit |uvw>\n"
            "        seq |three> => ssplit |xyz>\n\n"
            "        op-sum[seq] split[\" \"] |one two three>\n"
            "            |a> + |u> + |x> . |b> + |v> + |y> . |c> + |w> + |z> . |d> . |e>\n\n"
            "    see also:\n"
            "        common, op-union\n";

    operator_usage_map.map["spike-merge"] =
            "\nspike-merge:\n"
            "    description:\n"
            "        spike-merge[t] input-seq\n"
            "        merge t time steps of superpositions in the given input sequence\n"
            "        the motivation for this operator is the idea of spike trains in neural circuits\n"
            "        this operator takes a t time step sum of spikes,\n"
            "        resulting in a more compressed spike train,\n"
            "        that corresponds to a longer measurement window\n\n"
            "    examples:\n"
            "        -- just an abstract example:\n"
            "        spike-merge[2] ssplit |abcdefghi>\n"
            "            |a> + |b> . |c> + |d> . |e> + |f> . |g> + |h> . |i>\n\n"
            "        -- and another:\n"
            "        spike-merge[3] ssplit |abcdefghi>\n"
            "            |a> + |b> + |c> . |d> + |e> + |f> . |g> + |h> + |i>\n\n"
            "        -- an example closer to that of a neural spike train:\n"
            "        -- note that for this to work we make use of |> as the identity element for superpositions\n"
            "        -- ie: sp + |> == |> + sp == sp, for any superposition sp\n"
            "        the |spike train> => 3|a> . |> . |> . |> . 5|b> . |> . |c> . |> . |> . |> . |> . |> . 2|d> . |> . |>\n\n"
            "        spike-merge[2] the |spike train>\n"
            "            3|a> . |> . 5|b> . |c> . |> . |> . 2|d> . |>\n\n"
            "        spike-merge[3] the |spike train>\n"
            "            3|a> . 5|b> . |c> . |> . 2|d>\n\n"
            "        spike-merge[4] the |spike train>\n"
            "            3|a> . 5|b> + |c> . |> . 2|d>\n\n"
            "        spike-merge[5] the |spike train>\n"
            "            3|a> + 5|b> . |c> . 2|d>\n\n"
            "        spike-merge[6] the |spike train>\n"
            "            3|a> + 5|b> . |c> . 2|d>\n\n"
            "        spike-merge[7] the |spike train>\n"
            "            3|a> + 5|b> + |c> . 2|d> . |>\n\n"
            "        spike-merge[8] the |spike train>\n"
            "            3|a> + 5|b> + |c> . 2|d>\n\n\n"
            "        -- we can also merge spike trains using the op-sum[] operator\n"
            "        the-spike-train |1> => 3|a> . |> . |> . |> . 5|b> . |> . |c> . |> . |> . |> . |> . |> . 2|d> . |> . |>\n"
            "        the-spike-train |2> => |> . |> . 9|x> . |> . |> . |y> . |> . |> . |> . |> . 13|z> . |> . |>\n"
            "        the-spike-train |3> => |> . |u> . |> . |v> . |> . |w> . |> . |> . |> . |>\n\n"
            "        -- now merge them:\n"
            "        op-sum[the-spike-train] split[\" \"] |1 2 3>\n"
            "            3|a> . |u> . 9|x> . |v> . 5|b> . |y> + |w> . |c> . |> . |> . |> . 13|z> . |> . 2|d> . |> . |>\n\n"
            "    see also:\n"
            "        op-sum\n";

    operator_usage_map.map["random"] =
            "\nrandom:\n"
            "    description:\n"
            "        random[mu, sigma] ket\n"
            "        multiply the coeff x by a random number from a normal distribution\n"
            "        where mean = mu, and standard-deviation = sigma\n\n"
            "    examples:\n"
            "        random[1, 0.7] range(|1>, |5>)\n"
            "            1.352593|1> + 2.120979|2> + 2.134905|3> - 0.163504|4> + 1.371605|5>\n\n"
            "    see also:\n";

}

std::string OperatorUsageMap::get_usage(const std::string &s) const {
    auto it = map.find(s);
    if (it == map.end()) { return ""; }
    return it->second;
}

bool OperatorUsageMap::usage_is_defined(const std::string &s) const {
    auto it = map.find(s);
    return it != map.end();
}