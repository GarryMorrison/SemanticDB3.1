//
// Created by Garry Morrison on 20/11/2020.
//

#include "OperatorUsageMap.h"

OperatorUsageMap operator_usage_map;

OperatorUsageMap::OperatorUsageMap() {
    operator_usage_map.map["empty"] =
            "\nempty:\n"
            "    description:\n\n"
            "    examples:\n\n"
            "    see also:\n";

    operator_usage_map.map["clean"] =
            "\nclean:\n"
            "    description:\n"
            "        clean ket\n"
            "        clean the coefficients of the given superposition\n"
            "        if x < 0, return 0, else return 1\n"
            "        The combination: drop clean sp\n"
            "        converts the given superposition into a \"clean\" superposition\n\n"
            "    examples:\n"
            "        -- clean a superposition:\n"
            "        clean (3|a> + 2.2|b> - 3 |c> + |d>)\n"
            "            |a> + |b> + 0|c> + |d>\n\n"
            "        -- generate a \"clean\" superposition from an arbitrary superposition:\n"
            "        drop clean (3|a> + 2.2|b> - 3 |c> + |d>)\n"
            "            |a> + |b> + |d>\n\n"
            "    see also:\n"
            "        drop, ReLU, invert\n";

    operator_usage_map.map["ReLU"] =
            "\nReLU:\n"
            "    description:\n"
            "        ReLU ket\n"
            "        if x <= 0, return 0, else return x\n"
            "        see: https://en.wikipedia.org/wiki/Rectifier_(neural_networks)\n\n"
            "    examples:\n"
            "        ReLU (3|a> + 2.2|b> - 3 |c> + |d>)\n"
            "            3|a> + 2.200000|b> + 0|c> + |d>\n\n"
            "    see also:\n"
            "        clean, invert\n";

    operator_usage_map.map["invert"] =
            "\ninvert:\n"
            "    description:\n"
            "        invert ket\n"
            "        if x approx == 0, return 0, else return 1 / x\n\n"
            "    examples:\n"
            "        invert (3|a> + 2.2|b> - 3 |c> + |d>)\n"
            "            0.333333|a> + 0.454545|b> - 0.333333|c> + |d>\n\n"
            "    see also:\n"
            "        clean, ReLU\n";


    operator_usage_map.map["drop"] =
            "\ndrop:\n"
            "    description:\n"
            "        drop sp\n"
            "        drop all kets with coeff <= 0 from the given superposition\n\n"
            "    examples:\n"
            "        drop (|a> + 0|b> - 2|c> + 7.1|d>)\n"
            "            |a> + 7.100000|d>\n\n"
            "    see also:\n"
            "        drop-below, drop-above, sdrop\n";

    operator_usage_map.map["filter"] =
            "\nfilter:\n"
            "    description:\n"
            "        filter(operators, conditions) input-seq\n"
            "        Filters the input sequence to only those elements that satisfy the operator/condition pair\n"
            "        It is more powerful than the such-that[] operator, but probably slower\n"
            "        NB: input-seq structure is now preserved\n\n"
            "    examples:\n"
            "        -- learn some knowledge\n"
            "        is-food |bread> => |yes>\n"
            "        is-food |cheese> => |yes>\n"
            "        is-food |steak> => |yes>\n\n"
            "        is-furniture |chair> => |yes>\n"
            "        is-furniture |table> => |yes>\n"
            "        is-furniture |stool> => |yes>\n"
            "        is-furniture |lounge> => |yes>\n\n"
            "        is-day-of-week |monday> => |yes>\n"
            "        is-day-of-week |tuesday> => |yes>\n"
            "        is-day-of-week |wednesday> => |yes>\n"
            "        is-day-of-week |thursday> => |yes>\n"
            "        is-day-of-week |friday> => |yes>\n"
            "        is-day-of-week |saturday> => |yes>\n"
            "        is-day-of-week |sunday> => |yes>\n\n"
            "        -- now try some filters:\n"
            "        -- filter all known kets to those that are furniture:\n"
            "        filter(|op: is-furniture>, |yes>) rel-kets[*]\n"
            "            |chair> + |table> + |stool> + |lounge>\n\n"
            "        -- filter all known kets to those that are food:\n"
            "        filter(|op: is-food>, |yes>) rel-kets[*]\n"
            "            |bread> + |cheese> + |steak>\n\n"
            "        -- filter all known kets to those that are days of the week:\n"
            "        filter(|op: is-day-of-week>, |yes>) rel-kets[*]\n"
            "            |monday> + |tuesday> + |wednesday> + |thursday> + |friday> + |saturday> + |sunday>\n\n\n"
            "        -- an indirect filter example, first learn some knowledge:\n"
            "        father |John> => |Fred>\n"
            "        occupation |Fred> => |politician>\n\n"
            "        father |Sam> => |Robert>\n"
            "        occupation |Robert> => |doctor>\n\n"
            "        father |Emma> => |Jack>\n"
            "        occupation |Jack> => |nurse>\n\n"
            "        -- find people that have a father with occupation nurse:\n"
            "        -- NB: Note the ops: rather than op: to signify operator sequence rather than just an operator\n"
            "        filter(|ops: occupation father>, |nurse>) rel-kets[*]\n"
            "            |Emma>\n\n"
            "        -- find people that have a father with occupation doctor:\n"
            "        filter(|ops: occupation father>, |doctor>) rel-kets[*]\n"
            "            |Sam>\n\n\n"
            "        -- find people that have the father operator defined:\n"
            "        -- which is very close in function to the rel-kets[father] operator\n"
            "        filter(|op: father>, |*>) rel-kets[*]\n"
            "            |John> + |Sam> + |Emma>\n\n"
            "        -- filter to people that have a father with occupation of either doctor or nurse:\n"
            "        filter(|ops: occupation father>, |doctor> + |nurse>) rel-kets[*]\n"
            "            |Sam> + |Emma>\n\n"
            "        -- filter to those that have a rule of any type that is doctor or nurse:\n"
            "        -- NB: if rel-kets[*] is large, or supported-ops is large, this may be slow.\n"
            "        filter(|*>, |doctor> + |nurse>) rel-kets[*]\n"
            "            |Robert> + |Jack>\n\n\n"
            "        -- Finally, filters can be easily chained.\n"
            "        -- Eg, To find all kets that are human, American and are politicians:\n"
            "        -- NB: will be faster if you apply the most strict condition(s) first.\n"
            "        -- Eg, in this case, politician first, then American, then human.\n"
            "        filter(|op: is-human>, |yes>) filter(|op: is-american>, |yes>) filter(|op: occupation>, |politician>) rel-kets[*]\n\n\n"
            "        -- What if we want to find all the known words that are their own plural?\n"
            "        -- first, load some knowledge about words and their plurals:\n"
            "        load plural.sw3\n\n"
            "        -- now the required operator:\n"
            "        -- which returns the input ket if its' plural equals itself, else the empty ket |>\n"
            "        equal-plural |*> #=> filter(|op: plural>, |_self>) |_self>\n\n"
            "        -- now apply it to all known kets:\n"
            "        equal-plural rel-kets[*]\n"
            "            |fish> + |sheep> + |series> + |shrimp> + |species> + |swine> + |trout> + |tuna>\n\n"
            "    see also:\n"
            "        not-filter, such-that, rel-kets\n"
            "        plural.sw3";

    operator_usage_map.map["not-filter"] =
            "\nnot-filter:\n"
            "    description:\n"
            "        not-filter(operators, conditions) input-seq\n"
            "        Filters the input sequence to only those elements that don't satisfy the operator/condition pair\n"
            "        It is the brother of filter()\n\n"
            "    examples:\n"
            "        -- First, learn some knowledge:\n"
            "        father |John> => |Fred>\n"
            "        occupation |Fred> => |politician>\n\n"
            "        father |Sam> => |Robert>\n"
            "        occupation |Robert> => |doctor>\n\n"
            "        father |Emma> => |Jack>\n"
            "        occupation |Jack> => |nurse>\n\n\n"
            "        -- filter to those that don't have a rule of any type that is doctor or nurse:\n"
            "        -- NB: if rel-kets[*] is large, or supported-ops is large, this may be slow.\n"
            "        not-filter(|*>, |doctor> + |nurse>) rel-kets[*]\n"
            "            |John> + |Fred> + |Sam> + |Emma>\n\n\n"
            "        -- find people that don't have the father operator defined:\n"
            "        not-filter(|op: father>, |*>) rel-kets[*]\n"
            "            |Fred> + |Robert> + |Jack>\n\n\n"
            "        -- filter to people that don't have a father with occupation of either doctor or nurse:\n"
            "        not-filter(|ops: occupation father>, |doctor> + |nurse>) rel-kets[*]\n"
            "            |John> + |Fred> + |Robert> + |Jack>\n\n"
            "    see also:\n"
            "        filter";

    operator_usage_map.map["apply"] =
            "\napply:\n"
            "    description:\n"
            "        apply(seq, seq)\n"
            "        wrapper around apply op\n\n"
            "    examples:\n"
            "        -- learn some knowledge\n"
            "        age |Fred> => |35>\n"
            "        nick-name |Fred> => |Freddie>\n"
            "        mother |Fred> => |Jude>\n"
            "        father |Fred> => |Tom>\n"
            "        age |Jude> => |61>\n\n"
            "        -- implements: age |Fred>\n"
            "        apply(|op: age>, |Fred>)\n"
            "            |35>\n\n"
            "        -- implements: age |Fred> + mother |Fred> + father |Fred>\n"
            "        apply(|op: age> + |op: mother> + |op: father>, |Fred>)\n"
            "            |35> + |Jude> + |Tom>\n\n"
            "        -- implements: age |Fred> . mother |Fred> . father |Fred>\n"
            "        apply(|op: age> . |op: mother> . |op: father>, |Fred>)\n"
            "            |35> . |Jude> . |Tom>\n\n"
            "        -- the star operator, which adds all the right hand rules together:\n"
            "        star |*> #=> apply(supported-ops|_self>, |_self>) |>\n\n"
            "        -- Eg, applied to Fred:\n"
            "        star |Fred>\n"
            "            |35> + |Freddie> + |Jude> + |Tom>\n\n"
            "        -- using an operator sequence instead:\n"
            "        -- implements: age mother |Fred>\n"
            "        apply(|ops: age mother>, |Fred>)\n"
            "            |61>\n\n"
            "    see also:\n"
            "        learn, add-learn, seq-learn";

    operator_usage_map.map["learn"] =
            "\nlearn:\n"
            "    description:\n"
            "        learn(sp, sp, seq)\n"
            "        wrapper around a learn rule\n\n"
            "    examples:\n"
            "        -- implements: age |Fred> => |37>\n"
            "        learn(|op: age>, |Fred>, |37>)\n\n"
            "    see also:\n"
            "         add-learn, seq-learn, apply";

    operator_usage_map.map["add-learn"] =
            "\nadd-learn:\n"
            "    description:\n"
            "        add-learn(sp, sp, seq)\n"
            "        wrapper around an add-learn rule\n\n"
            "    examples:\n"
            "        -- implements: friend |Fred> +=> |Sam>\n"
            "        -- implements: friend |Fred> +=> |Emma>\n"
            "        add-learn(|op: friend>, |Fred>, |Sam>)\n"
            "        add-learn(|op: friend>, |Fred>, |Emma>)\n\n"
            "    see also:\n"
            "         learn, seq-learn, apply";

    operator_usage_map.map["seq-learn"] =
            "\nseq-learn:\n"
            "    description:\n"
            "        seq-learn(sp, sp, seq)\n"
            "        wrapper around a seq-learn rule\n\n"
            "    examples:\n"
            "        -- implements: friend |Fred> .=> |Sam>\n"
            "        -- implements: friend |Fred> .=> |Emma>\n"
            "        seq-learn(|op: friend>, |Fred>, |Sam>)\n"
            "        seq-learn(|op: friend>, |Fred>, |Emma>)\n\n"
            "    see also:\n"
            "         learn, add-learn, apply";

    operator_usage_map.map["smerge"] =
            "\nsmerge:\n"
            "    description:\n"
            "        smerge seq\n"
            "        smerge[\"str\"] seq\n"
            "        merges a sequence into a single string, optionally separated by the str string\n\n"
            "    examples:\n"
            "        smerge (|F> . |r> . |e> . |d>)\n"
            "            |Fred>\n\n"
            "        smerge[\", \"] (|a> . |b> . |c> . |d>)\n"
            "            |a, b, c, d>\n\n"
            "        -- define the bracket operator:\n"
            "        bracket (*) #=> |[> _ smerge[\", \"] |__self> _ |]>\n\n"
            "        -- define the print-bracket operator:\n"
            "        print-bracket (*) #=> print bracket |__self>\n\n"
            "        -- quick test of the bracket operator:\n"
            "        bracket (|F> . |r> . |e> . |d>)\n"
            "            |[F, r, e, d]>\n\n"
            "        -- quick test of the print-bracket operator:\n"
            "        print-bracket (|F> . |r> . |e> . |d>)\n"
            "            [F, r, e, d]\n"
            "            |[F, r, e, d]>\n\n"
            "    see also:\n"
            "        ssplit, smap";

    operator_usage_map.map["learn-grid"] =
            "\nlearn-grid:\n"
            "    description:\n"
            "        learn-grid[width, height]\n"
            "        learn-grid[width, height, operator]\n"
            "        learn a grid of specified width and height\n"
            "        all cells initialized to zero, with respect to operator \"operator\"\n"
            "        if operator is not specified, use \"value\"\n"
            "        and we learn all direction operators, N, NE, E, SE, S, SW, W, NW, that don't point outside the grid\n\n"
            "    examples:\n"
            "        -- learn a sample grid:\n"
            "        learn-grid[2,2]\n"
            "        dump\n"
            "        ------------------------------------------\n"
            "        |context> => |Global context>\n"
            "\n"
            "        value |grid: 0: 0> => |0>\n"
            "        E |grid: 0: 0> => |grid: 0: 1>\n"
            "        SE |grid: 0: 0> => |grid: 1: 1>\n"
            "        S |grid: 0: 0> => |grid: 1: 0>\n"
            "\n"
            "        value |grid: 0: 1> => |0>\n"
            "        S |grid: 0: 1> => |grid: 1: 1>\n"
            "        SW |grid: 0: 1> => |grid: 1: 0>\n"
            "        W |grid: 0: 1> => |grid: 0: 0>\n"
            "\n"
            "        value |grid: 1: 0> => |0>\n"
            "        N |grid: 1: 0> => |grid: 0: 0>\n"
            "        NE |grid: 1: 0> => |grid: 0: 1>\n"
            "        E |grid: 1: 0> => |grid: 1: 1>\n"
            "\n"
            "        value |grid: 1: 1> => |0>\n"
            "        N |grid: 1: 1> => |grid: 0: 1>\n"
            "        W |grid: 1: 1> => |grid: 1: 0>\n"
            "        NW |grid: 1: 1> => |grid: 0: 0>\n"
            "        ------------------------------------------\n\n"
            "    see also:\n"
            "        display-grid";

    operator_usage_map.map["display-grid"] =
            "\ndisplay-grid:\n"
            "    description:\n"
            "        display-grid[width, height]\n"
            "        display-grid[width, height, operator]\n"
            "        display-grid[width, height, operator, empty-char]\n"
            "        display a rectangular map of the given width and height\n"
            "        where each cell is the value of \"operator\" applied to that cell (default operator is \"value\")\n"
            "        where empty-char is printed for cells with value 0 (default value of empty-char is \".\")\n\n"
            "    examples:\n"
            "        -- learn a small grid first:\n"
            "        learn-grid[9,5]\n\n"
            "        -- learn some cell values:\n"
            "        value |grid: 2: 2> => |H>\n"
            "        value |grid: 2: 3> => |e>\n"
            "        value |grid: 2: 4> => |l>\n"
            "        value |grid: 2: 5> => |l>\n"
            "        value |grid: 2: 6> => |o>\n\n"
            "        -- display the resulting grid:\n"
            "        display-grid[9, 5, value, \"*\"]\n"
            "            width:  9\n"
            "            height: 5\n"
            "\n"
            "            0      *   *   *   *   *   *   *   *   *\n"
            "            1      *   *   *   *   *   *   *   *   *\n"
            "            2      *   *   H   e   l   l   o   *   *\n"
            "            3      *   *   *   *   *   *   *   *   *\n"
            "            4      *   *   *   *   *   *   *   *   *\n\n"
            "    see also:\n"
            "        learn-grid";

    operator_usage_map.map["how-many"] =
            "\nhow-many:\n"
            "    description:\n"
            "        how-many sp\n"
            "        counts the number of kets in a superposition\n\n"
            "    examples:\n"
            "        how-many split |abcdef>\n"
            "            |number: 6>\n\n"
            "    see also:\n"
            "        measure-currency, show-many";

    operator_usage_map.map["show-many"] =
            "\nshow-many:\n"
            "    description:\n"
            "        show-many seq\n"
            "        counts the number of superpositions in a sequence\n\n"
            "    examples:\n"
            "        show-many ssplit |abcdef>\n"
            "            |number: 6>\n\n"
            "    see also:\n"
            "        how-many, measure-currency, how-many";

    operator_usage_map.map["measure-currency"] =
            "\nmeasure-currency:\n"
            "    description:\n"
            "        measure-currency sp\n"
            "        measures the \"currency\" used by a superposition\n"
            "        Ie, the sum of the coefficients of all the kets in the given superposition\n"
            "        If the superposition is \"clean\" then measure-currency is the same as the how-many operator\n\n"
            "    examples:\n"
            "        measure-currency (3|a> + 1.2|b> + 0.1|c>)\n"
            "            |number: 4.3>\n\n"
            "    see also:\n"
            "        how-many, show-many, clean";

    operator_usage_map.map["reverse"] =
            "\nreverse:\n"
            "    description:\n"
            "        reverse sp\n"
            "        reverse the given superposition\n\n"
            "    examples:\n"
            "        reverse (5.1|a> + 3.7|b> + |c> - 2.1|d>)\n"
            "            - 2.100000|d> + |c> + 3.700000|b> + 5.100000|a>\n\n"
            "    see also:\n"
            "        sreverse";

    operator_usage_map.map["sreverse"] =
            "\nsreverse:\n"
            "    description:\n"
            "        sreverse seq\n"
            "        reverse the given sequence\n\n"
            "    examples:\n"
            "        sreverse (5.1|a> . 3.7|b> . |c>)\n"
            "            |c> . 3.700000|b> . 5.100000|a>\n\n"
            "    see also:\n"
            "        reverse";

    operator_usage_map.map["sp2seq"] =
            "\nsp2seq:\n"
            "    description:\n"
            "        sp2seq sp\n"
            "        convert the given superposition into a sequence\n\n"
            "    examples:\n"
            "        sp2seq (|a> + |b> + |c>)\n"
            "            |a> . |b> . |c>\n\n"
            "    see also:\n"
            "        seq2sp";

    operator_usage_map.map["seq2sp"] =
            "\nseq2sp:\n"
            "    description:\n"
            "        seq2sp seq\n"
            "        convert the given sequence into a superposition\n\n"
            "    examples:\n"
            "        seq2sp (|a> . |b> . |c>)\n"
            "            |a> + |b> + |c>\n\n"
            "    see also:\n"
            "        sp2seq";

    operator_usage_map.map["plus"] =
            "\nplus:\n"
            "    description:\n"
            "        plus[n] ket\n"
            "        add n to the value in the ket, leaving the coefficient unchanged\n\n"
            "    examples:\n"
            "        plus[5] |3.1415>\n"
            "            |8.1415>\n\n"
            "    see also:\n"
            "        minus, times-by, divide-by, int-divide-by, mod, round";

    operator_usage_map.map["minus"] =
            "\nminus:\n"
            "    description:\n"
            "        minus[n] ket\n"
            "        subtract n from the value in the ket, leaving the coefficient unchanged\n\n"
            "    examples:\n"
            "        minus[2] |3.1415>\n"
            "            |1.1415>\n"
            "    see also:\n"
            "        plus, times-by, divide-by, int-divide-by, mod, round";

    operator_usage_map.map["times-by"] =
            "\ntimes-by:\n"
            "    description:\n"
            "        times-by[n] ket\n"
            "        times the value in the ket by n, leaving the coefficient unchanged\n\n"
            "    examples:\n"
            "        times-by[5] |6.1>\n"
            "            |30.5>\n\n"
            "    see also:\n"
            "        plus, minus, divide-by, int-divide-by, mod, round\n"
            "        temperature-conversion.sw3";

    operator_usage_map.map["divide-by"] =
            "\ndivide-by:\n"
            "    description:\n"
            "        divide-by[n] ket\n"
            "        divide the value in the ket by n, leaving the coefficient unchanged\n\n"
            "    examples:\n"
            "        divide-by[5] |625.5>\n"
            "            |125.1>\n\n"
            "    see also:\n"
            "        plus, minus, times-by, int-divide-by, mod, round";

    operator_usage_map.map["int-divide-by"] =
            "\nint-divide-by:\n"
            "    description:\n"
            "        int-divide-by[n] ket\n"
            "        integer divide the value in the ket by n, leaving the coefficient unchanged\n\n"
            "    examples:\n"
            "        int-divide-by[1000] |123456>\n"
            "            |123>\n\n"
            "    see also:\n"
            "        plus, minus, times-by, divide-by, mod, round";

    operator_usage_map.map["mod"] =
            "\nmod:\n"
            "    description:\n"
            "        mod[n] ket\n"
            "        apply mod n to the value in the ket by n, leaving the coefficient unchanged\n\n"
            "    examples:\n"
            "        mod[1000] |1234567>\n"
            "            |567>\n\n"
            "    see also:\n"
            "        plus, minus, times-by, divide-by, int-divide-by, round";

    operator_usage_map.map["round"] =
            "\nround:\n"
            "    description:\n"
            "        round[n] ket\n"
            "        round the value in the ket to n places, leaving the coefficient unchanged\n"
            "        If you need more decimal places in your kets, use the --places command line option.\n"
            "        The default is currently set to 5\n\n"
            "    examples:\n"
            "        round[3] |3.14159>\n"
            "            |3.142>\n\n"
            "    see also:\n"
            "        plus, minus, times-by, divide-by, int-divide-by, mod";

    operator_usage_map.map["to-upper"] =
            "\nto-upper:\n"
            "    description:\n"
            "        to-upper ket\n"
            "        set all characters to upper case\n\n"
            "        to-upper[i1, i2, ..., in] ket\n"
            "        change i'th characters to upper case\n\n"
            "    examples:\n"
            "        to-upper |fred>\n"
            "            |FRED>\n\n"
            "        to-upper[1] |fred>\n"
            "            |Fred>\n\n"
            "        to-upper[1,3,5] |abcdefg>\n"
            "            |AbCdEfg>\n\n"
            "    see also:\n"
            "        to-lower";

    operator_usage_map.map["to-lower"] =
            "\nto-lower:\n"
            "    description:\n"
            "        to-lower ket\n"
            "        set all characters to lower case\n\n"
            "        to-lower[i1, i2, ..., in] ket\n"
            "        change i'th characters to lower case\n\n"
            "    examples:\n"
            "        to-lower |FRED>\n"
            "            |fred>\n\n"
            "        to-lower[1] |FRED>\n"
            "            |fRED>\n\n"
            "        to-lower[1,3,5] |ABCDEFG>\n"
            "            |aBcDeFG>\n\n"
            "    see also:\n"
            "        to-upper";

    operator_usage_map.map["split"] =
            "\nsplit:\n"
            "    description:\n"
            "        split ket\n"
            "        splits the ket into a superposition\n\n"
            "        split[\"str\"] ket\n"
            "        splits the ket into a superposition, splitting on str\n\n"
            "    examples:\n"
            "        split |abcde>\n"
            "            |a> + |b> + |c> + |d> + |e>\n\n"
            "        split[\"d\"] |abcdef>\n"
            "            |abc> + |ef>\n\n"
            "        split[\"g\"] split[\"d\"] |abcdefghij>\n"
            "            |abc> + |ef> + |hij>\n\n"
            "    see also:\n"
            "        ssplit";

    operator_usage_map.map["ssplit"] =
            "\nssplit:\n"
            "    description:\n"
            "        ssplit ket\n"
            "        splits the ket into a sequence\n\n"
            "        ssplit[\"str\"] ket\n"
            "        splits the ket into a sequence, splitting on str\n\n"
            "    examples:\n"
            "        ssplit |abcde>\n"
            "            |a> . |b> . |c> . |d> . |e>\n\n"
            "        ssplit[\", \"] |a, b, c>\n"
            "            |a> . |b> . |c>\n\n"
            "        ssplit[\" and \"] |a, b, c and d>\n"
            "            |a, b, c> . |d>\n\n"
            "        ssplit[\", \"] ssplit[\" and \"] |a, b, c and d>\n"
            "            |a> . |b> . |c> . |d>\n\n"
            "    see also:\n"
            "        split, smerge";

    operator_usage_map.map["extract-category"] =
            "\nextract-category:\n"
            "    description:\n"
            "        extract-category ket\n"
            "        extract the \"category\" from the given ket\n"
            "        categories are separated by \": \"\n"
            "        with the most general category on the left, and the most specific on the right\n"
            "        for example |animal: mammal: dog>\n"
            "        has the most general category \"animal\", then the category \"mammal\" and then finally the \"value\" dog\n"
            "        categories can be considered a type for the object\n"
            "        Eg, |word: house> says house is a type of word\n"
            "        and |food: apple> says apple is a type of food\n"
            "        and we can define operators with respect to them\n"
            "        Eg, op |food: *> #=> ...\n"
            "        will define \"op\" with respect to all objects of type\\category \"food\".\n\n"
            "    examples:\n"
            "        -- if there is no category, then return the empty ket:\n"
            "        -- NB: this is in contrast to the python version of the Semantic DB which would instead return |dog>\n"
            "        extract-category |dog>\n"
            "            |>\n\n"
            "        -- remove the \"value\" from the ket:\n"
            "        -- in other words, extract the category of the ket\n"
            "        extract-category |animal: mammal: dog>\n"
            "            |animal: mammal>\n\n"
            "        -- remove the \"value\" from the ket, and then the most specific \"category\":\n"
            "        extract-category extract-category |animal: mammal: dog>\n"
            "            |animal>\n\n"
            "        -- or using the powered-operator notation:\n"
            "        extract-category^2 |animal: mammal: dog>\n"
            "            |animal>\n\n"
            "        -- an abstract example:\n"
            "        extract-category |a: b: c: d: e: f>\n"
            "            |a: b: c: d: e>\n\n"
            "    see also:\n"
            "        extract-value, extract-head, extract-tail";

    operator_usage_map.map["extract-value"] =
            "\nextract-value:\n"
            "    description:\n"
            "        extract-value ket\n"
            "        extract the value, ie, remove the category, from the given ket\n"
            "        categories are separated by \": \"\n"
            "        with the most general category on the left, and the most specific on the right\n"
            "        for example |animal: mammal: dog>\n"
            "        has the most general category \"animal\", then the category \"mammal\" and then finally the \"value\" dog\n"
            "        categories can be considered a type for the object\n"
            "        and values are specific examples of that type\n"
            "        Eg, |food: apple> says apple is a type of food, and the value of |food: apple> is apple\n\n"
            "    examples:\n"
            "        -- if there is no category, then return unchanged:\n"
            "        extract-value |dog>\n"
            "            |dog>\n\n"
            "        extract-value |animal: mammal: dog>\n"
            "            |dog>\n\n"
            "        -- an abstract example:\n"
            "        extract-value |a: b: c: d: e: f>\n"
            "            |f>\n\n"
            "    see also:\n"
            "        extract-category, extract-head, extract-tail";

    operator_usage_map.map["extract-head"] =
            "\nextract-head:\n"
            "    description:\n"
            "        extract-head ket\n"
            "        categories are separated by \": \"\n"
            "        with the most general category on the left, and the most specific on the right\n"
            "        for example |animal: mammal: dog>\n"
            "        has the most general category \"animal\", then the category \"mammal\" and then finally the \"value\" dog\n"
            "        This list of categories and the value can be considered a type of list\n"
            "        extract-head returns the first element, or head, of this list\n\n"
            "    examples:\n"
            "        -- if there is no category, then return unchanged:\n"
            "        extract-head |dog>\n"
            "            |dog>\n\n"
            "        extract-head |animal: mammal: dog>\n"
            "            |animal>\n\n"
            "        -- an abstract example:\n"
            "        extract-head |a: b: c: d: e: f>\n"
            "            |a>\n\n"
            "    see also:\n"
            "        extract-category, extract-value, extract-tail";

    operator_usage_map.map["extract-tail"] =
            "\nextract-tail:\n"
            "    description:\n"
            "        extract-tail ket\n"
            "        categories are separated by \": \"\n"
            "        with the most general category on the left, and the most specific on the right\n"
            "        for example |animal: mammal: dog>\n"
            "        has the most general category \"animal\", then the category \"mammal\" and then finally the \"value\" dog\n"
            "        This list of categories and the value can be considered a type of list\n"
            "        extract-tail returns the tail of this list\n"
            "        Ie, with the first category removed\n\n"
            "    examples:\n"
            "        -- if there is no category, then return the empty ket:\n"
            "        extract-tail |dog>\n"
            "            |>\n\n"
            "        extract-tail |animal: mammal: dog>\n"
            "            |mammal: dog>\n\n"
            "        -- an abstract example:\n"
            "        extract-tail |a: b: c: d: e: f>\n"
            "            |b: c: d: e: f>\n\n"
            "    see also:\n"
            "        extract-category, extract-value, extract-head";

    operator_usage_map.map["print"] =
            "\nprint:\n"
            "    description:\n"
            "        print ket\n"
            "        print the given ket to standard out, appending a new line\n"
            "        often used with the infix operators _ and __ which join ket labels, where __ inserts an extra space\n"
            "        also frequently used with the smerge[] operator\n"
            "        print returns the input ket, so it can be chained with other operators\n\n"
            "    examples:\n"
            "        print |Just a short sentence.>\n"
            "            Just a short sentence.\n"
            "            |Just a short sentence.>\n"
            "        print (|A> __ |short> __ |example> _ |.>)\n"
            "            A short example.\n"
            "            |A short example.>\n\n"
            "        print smerge[\", \"] (|a> . |b> . |c>)\n"
            "            a, b, c\n"
            "            |a, b, c>\n\n"
            "    see also:\n"
            "        to-upper, to-lower, smerge";

    operator_usage_map.map["threshold-filter"] =
            "\nthreshold-filter:\n"
            "    description:\n"
            "        threshold-filter[t] ket\n"
            "        if x < t, return 0, else return x\n"
            "        combined with drop, eg: drop threshold-filter[t] sp\n"
            "        filter the given superposition to only those with coefficients >= t.\n\n"
            "    examples:\n"
            "        threshold-filter[2] (3|a> + 2.2|b> - 3 |c> + |d>)\n"
            "            3|a> + 2.200000|b> + 0|c> + 0|d>\n\n"
            "        drop threshold-filter[2] (3|a> + 2.2|b> - 3 |c> + |d>)\n"
            "            3|a> + 2.200000|b>\n\n"
            "    see also:\n"
            "        not-threshold-filter";

    operator_usage_map.map["not-threshold-filter"] =
            "\nnot-threshold-filter:\n"
            "    description:\n"
            "        not-threshold-filter[t] ket\n"
            "        if x <= t, return x, else return 0\n\n"
            "    examples:\n"
            "        not-threshold-filter[2] (3|a> + 2.2|b> - 3 |c> + |d>)\n"
            "            0|a> + 0|b> - 3|c> + |d>\n\n"
            "    see also:\n"
            "        threshold-filter";

    operator_usage_map.map["sigmoid-in-range"] =
            "\nsigmoid-in-range:\n"
            "    description:\n"
            "        sigmoid-in-range[a, b] ket\n"
            "        if a <= x <= b, return x, else return 0\n\n"
            "    examples:\n"
            "        sigmoid-in-range[2,4] (|a> + 2|b> + 3|c> + 4|d> + 5|e>)\n"
            "            0|a> + 2|b> + 3|c> + 4|d> + 0|e>\n\n"
            "    see also:\n"
            "        threshold-filter";

    operator_usage_map.map["op-zip"] =
            "\nop-zip:\n"
            "    description:\n"
            "        op-zip(seq) input-seq\n"
            "        zip together a sequence of operators with a sequence of superpositions (given by input-seq)\n"
            "        stops at the shorter of the two sequences\n"
            "        NB: it is invoked slightly differently from the python version\n"
            "        where it was: op-zip(seq, seq)\n\n"
            "    examples:\n"
            "        -- define some for-example operators:\n"
            "        -- but keep it abstract for now:\n"
            "        op1 (*) #=> |op1:> __ |__self>\n"
            "        op2 (*) #=> |op2:> __ |__self>\n"
            "        op3 (*) #=> |op3:> __ |__self>\n\n"
            "        -- define the corresponding operator sequence:\n"
            "        op |seq> => |op: op1> . |op: op2> . |op: op3>\n\n"
            "        -- define a for-example sequence, again, just something abstract:\n"
            "        the |input seq> => |a> . |b> . |c> . |d> . |e>\n\n"
            "        -- now apply it:\n"
            "        op-zip(op |seq>) the |input seq>\n"
            "            |op1: a> . |op2: b> . |op3: c>\n\n"
            "    see also:\n"
            "        numbers-to-words.sw3";

    operator_usage_map.map["if"] =
            "\nif:\n"
            "    description:\n"
            "        if(condition, operator1, operator2) input-seq\n"
            "        if condition evaluates to |yes> or |true> then apply operator1 to input-seq\n"
            "        else apply operator2 to input-seq\n"
            "        NB: the python version of if() is much uglier and clunkier.\n\n"
            "    examples:\n"
            "        -- just define a couple of abstract operators:\n"
            "        op1 (*) #=> |op1:> __ smerge[\", \"] |__self>\n"
            "        op2 (*) #=> |op2:> __ smerge[\", \"] |__self>\n\n"
            "        -- then apply it:\n"
            "        if(|yes>, |op: op1>, |op: op2>) ssplit |abc>\n"
            "            |op1: a, b, c>\n\n"
            "        if(|no>, |op: op1>, |op: op2>) ssplit |abc>\n"
            "            |op2: a, b, c>\n\n"
            "    see also:\n";

    operator_usage_map.map["is-less-than"] =
            "\nis-less-than:\n"
            "    description:\n"
            "        is-less-than[value] ket\n"
            "        returns yes/no if the value in ket < value\n\n"
            "    examples:\n"
            "        is-less-than[1000] |987>\n"
            "            |yes>\n\n"
            "        is-less-than[80] |age: 76>\n"
            "            |yes>\n\n"
            "        is-less-than[2000] |year: 2018>\n"
            "            |no>\n\n"
            "        -- if the ket has no float value then return the empty ket |>\n"
            "        is-less-than[13] |the cat>\n"
            "            |>\n\n"
            "    see also:\n"
            "        is-less-equal-than, is-equal, is-greater-than, is-greater-equal-than, is-in-range";

    operator_usage_map.map["is-less-equal-than"] =
            "\nis-less-equal-than:\n"
            "    description:\n"
            "        is-less-equal-than[value] ket\n"
            "        returns yes/no if the value in ket <= value\n\n"
            "    examples:\n"
            "        is-less-equal-than[80] |age: 76>\n"
            "            |yes>\n\n"
            "        is-less-equal-than[2010] |year: 2010>\n"
            "            |yes>\n\n"
            "        -- if the ket has no float value then return the empty ket |>\n"
            "        is-less-equal-than[13] |the cat>\n"
            "            |>\n\n"
            "    see also:\n"
            "        is-less-than, is-equal, is-greater-than, is-greater-equal-than, is-in-range";

    operator_usage_map.map["is-equal"] =
            "\nis-equal:\n"
            "    description:\n"
            "        is-equal[value] ket\n"
            "        returns yes/no if the value in ket == value\n\n"
            "    examples:\n"
            "        is-equal[80] |age: 76>\n"
            "            |no>\n\n"
            "        is-equal[2010] |year: 2010>\n"
            "            |yes>\n\n"
            "        -- if the ket has no float value then return the empty ket |>\n"
            "        is-equal[13] |the cat>\n"
            "            |>\n\n"
            "    see also:\n"
            "        is-less-than, is-less-equal-than, is-greater-than, is-greater-equal-than, is-in-range\n\n"
            "\nis-equal:\n"
            "    description:\n"
            "        is-equal(one, two)\n"
            "        returns |yes> if one == two, else |no>\n"
            "        Note, both the labels, and the coefficients must be equal\n"
            "        Be aware that currently one and two are converted to kets\n"
            "        So if one, and/or two are superpositions or sequences, it will not work as expected\n"
            "        Perhaps later will swap to using our similarity measure instead as a test of equality\n\n"
            "    examples:\n"
            "        is-equal(|a>, |a>)\n"
            "            |yes>\n\n"
            "        is-equal(|a>, |b>)\n"
            "            |no>\n\n"
            "    see also:\n"
            "        simm, strict-simm";

    operator_usage_map.map["is-greater-than"] =
            "\nis-greater-than:\n"
            "    description:\n"
            "        is-greater-than[value] ket\n"
            "        returns yes/no if the value in ket > value\n\n"
            "    examples:\n"
            "        is-greater-than[5] |7>\n"
            "            |yes>\n\n"
            "        is-greater-than[3] |price: 3.50>\n"
            "            |yes>\n\n"
            "        is-greater-than[26] |number: 25>\n"
            "            |no>\n\n"
            "        -- if the ket has no float value then return the empty ket |>\n"
            "        is-greater-than[13] |the cat>\n"
            "            |>\n\n"
            "    see also:\n"
            "        is-less-than, is-less-equal-than, is-equal, is-greater-equal-than, is-in-range";

    operator_usage_map.map["is-greater-equal-than"] =
            "\nis-greater-equal-than:\n"
            "    description:\n"
            "        is-greater-equal-than[value] ket\n"
            "        returns yes/no if the value in ket >= value\n\n"
            "    examples:\n"
            "        is-greater-equal-than[13] |number: 13>\n"
            "            |yes>\n\n"
            "        is-greater-equal-than[21] |age: 23>\n"
            "            |yes>\n\n"
            "        is-greater-equal-than[1980] |year: 1977>\n"
            "            |no>\n\n"
            "        -- if the ket has no float value then return the empty ket |>\n"
            "        is-greater-equal-than[13] |the cat>\n"
            "            |>\n\n"
            "    see also:\n"
            "        is-greater-than, is-less-than, is-less-equal-than, is-equal, is-in-range";

    operator_usage_map.map["is-in-range"] =
            "\nis-in-range:\n"
            "    description:\n"
            "        is-in-range[value1, value2] ket\n"
            "        returns yes/no if value1 <= the value in ket <= value2\n\n"
            "    examples:\n"
            "        is-in-range[2,4] ssplit |0123456>\n"
            "            |no> . |no> . |yes> . |yes> . |yes> . |no> . |no>\n\n"
            "        not |yes> => |no>\n"
            "        not |no> => |yes>\n"
            "        is-a-child |*> #=> is-in-range[0,17] age |_self>\n"
            "        is-a-teenager |*> #=> is-in-range[13,19] age |_self>\n"
            "        is-an-adult |*> #=> not is-in-range[0,17] age |_self>\n"
            "        age |Emma> => |14>\n"
            "        age |Bella> => |18>\n"
            "        age |Fred> => |34>\n\n"
            "        table[person, age, is-a-child, is-a-teenager, is-an-adult] split[\" \"] |Emma Bella Fred>\n"
            "            +--------+-----+------------+---------------+-------------+\n"
            "            | person | age | is-a-child | is-a-teenager | is-an-adult |\n"
            "            +--------+-----+------------+---------------+-------------+\n"
            "            | Emma   | 14  | yes        | yes           | no          |\n"
            "            | Bella  | 18  | no         | yes           | yes         |\n"
            "            | Fred   | 34  | no         | no            | yes         |\n"
            "            +--------+-----+------------+---------------+-------------+\n\n"
            "        -- if the ket has no float value then return the empty ket |>\n"
            "        is-in-range[13, 17] |the cat>\n"
            "            |>\n\n"
            "    see also:\n"
            "        is-less-than, is-less-equal-than, is-equal, is-greater-than, is-greater-equal-than";

    operator_usage_map.map["is-prime"] =
            "\nis-prime:\n"
            "    description:\n"
            "        is-prime ket\n"
            "        return |yes> or |no> if the given ket is prime or not\n\n"
            "    examples:\n"
            "        is-prime |379721>\n"
            "            |yes>\n"
            "    see also:\n"
            "        prime-factors";

    operator_usage_map.map["prime-factors"] =
            "\nprime-factors:\n"
            "    description:\n"
            "        prime-factors ket\n"
            "        returns a list/superposition of prime factors\n\n"
            "    examples:\n"
            "        prime-factors |987654321>\n"
            "            2|3> + 2|17> + |379721>\n\n"
            "        prime-factors |number: 123456789>\n"
            "            2|number: 3> + |number: 3607> + |number: 3803>\n\n"
            "    see also:\n"
            "        is-prime";

    operator_usage_map.map["such-that"] =
            "\nsuch-that:\n"
            "    description:\n"
            "        such-that[op] seq\n"
            "        filters the given sequence to those elements that return |yes> or |true> for op applied to that element\n"
            "        it is less powerful than filter() but on the other hand, it should be faster\n\n"
            "    examples:\n"
            "        is-hungry |Fred> => |no>\n"
            "        is-hungry |Sam> => |yes>\n"
            "        is-hungry |Emma> => |yes>\n"
            "        is-hungry |Liz> => |no>\n"
            "        such-that[is-hungry] rel-kets[*]\n"
            "            |Sam> + |Emma>\n\n"
            "        such-that[is-prime] srange(|1>, |20>)\n"
            "            |2> . |3> . |5> . |7> . |11> . |13> . |17> . |19>\n\n"
            "    see also:\n"
            "        filter";

    operator_usage_map.map["is-mbr"] =
            "\nis-mbr:\n"
            "    description:\n"
            "        is-mbr(ket) seq\n"
            "        returns |yes> if ket is in seq, else |no>\n"
            "        just a standard, set membership test\n"
            "        ie, is the given ket a member of the given set represented by seq\n\n"
            "    examples:\n"
            "        is-mbr(|b>) split |abc>\n"
            "            |yes>\n\n"
            "        is-mbr(|c>) (0.3|a> + 2|b> + 9.7|c> + 13|d>)\n"
            "            |yes>\n\n"
            "        is-mbr(|x>) (0.3|a> + 2|b> + 9.7|c> + 13|d>)\n"
            "            |no>\n\n"
            "        friends |Fred> => |Jack> + |Harry> + |Ed> + |Mary> + |Rob> + |Patrick> + |Emma> + |Charlie>\n\n"
            "        -- is Ed one of Fred's friends?\n"
            "        is-mbr(|Ed>) friends |Fred>\n"
            "            |yes>\n\n"
            "        -- is Jane one of Fred's friends?\n"
            "        is-mbr(|Jane>) friends |Fred>\n"
            "            |no>\n\n"
            "    see also:\n"
            "        is-subset, union, intersection";

    operator_usage_map.map["mbr"] =
            "\nmbr:\n"
            "    description:\n"
            "        mbr(ket) sp\n"
            "        returns the coeff of ket in the given superposition\n"
            "        if ket is not in the sp then the returned coeff is 0\n\n"
            "    examples:\n"
            "        mbr(|b>) (|a> + |b> + |c>)\n"
            "            |b>\n\n"
            "        mbr(|c>) (0.3|a> + 2|b> + 9.7|c> + 13|d>)\n"
            "            9.700000|c>\n\n"
            "        mbr(|x>) (0.3|a> + 2|b> + 9.7|c> + 13|d>)\n"
            "            0|x>\n\n"
            "    see also:\n"
            "        is-mbr";

    operator_usage_map.map["is-subset"] =
            "\nis-subset:\n"
            "    description:\n"
            "        is-subset(seq) input-seq\n"
            "        returns |yes> if seq is a \"subset\" of input-seq, else |no>\n"
            "        where subset means: for all kets in seq, they have value <= the value in input-seq\n"
            "        it generalizes the idea of sets and their subsets, since it allows elements to have corresponding coefficients\n"
            "        so for example: asking if {a,c} is a subset of {a,b,c,d,e}\n"
            "        is equivalent to: is-subset(|a> + |c>) (|a> + |b> + |c> + |d> + |e>)\n"
            "        or more compactly: is-subset(split |ac>) split |abcde>\n"
            "        this extends the notion that sets can be represented by \"clean\" superpositions\n"
            "        and non-clean superpositions represent fuzzy sets\n"
            "        where \"clean\" means all coefficients of kets are either 0 or 1\n\n"
            "    examples:\n"
            "        is-subset(|b>) split |abc>\n"
            "            |yes>\n\n"
            "        is-subset(split |bd>) split |abc>\n"
            "            |no>\n\n"
            "        -- note, the order of the elements in the superpositions do not matter:\n"
            "        is-subset(8|c> + 13|d> + 0.2|a>) (0.3|a> + 2|b> + 9.7|c> + 13|d>)\n"
            "            |yes>\n\n"
            "        friends |Fred> => |Sam> + |Emma> + |Rob> + |Liz> + |Harold> + |Tom>\n"
            "        friends |Sam> => |Emma> + |Tom> + |Liz>\n"
            "        friends |Harold> => |Rob> + |Liz> + |Tom> + |Beth>\n\n"
            "        -- are Sam's friends a subset of Fred's friends?\n"
            "        is-subset(friends |Sam>) friends |Fred>\n"
            "            |yes>\n\n"
            "        -- are Harold's friends a subset of Fred's friends?\n"
            "        is-subset(friends |Harold>) friends |Fred>\n"
            "            |no>\n\n"
            "    see also:\n"
            "        is-mbr, union, intersection";

    operator_usage_map.map["smap"] =
            "\nsmap:\n"
            "    description:\n"
            "        smap[min, max, op] seq\n"
            "        smap(min, max, op) seq\n"
            "        partition seq into ngrams of size ranging from min to max, then apply op to those ngrams\n"
            "        in the background, we have a variable that keeps track of the current position in the sequence:\n"
            "        the |smap pos>\n"
            "        NB: the indexing for the smap position starts from 1 not 0.\n\n"
            "    examples:\n"
            "        -- just an abstract test:\n"
            "        bracket (*) #=> |[> _ smerge[\", \"] |__self> _ |]>\n"
            "        print-bracket (*) #=> print bracket |__self>\n"
            "        print-smap-bracket (*) #=> print (the |smap pos> _ |:> __ bracket |__self>)\n\n"
            "        -- the constant parameter version:\n"
            "        smap[1, 4, print-smap-bracket] ssplit |abcdef>\n"
            "            1: [a]\n"
            "            2: [b]\n"
            "            3: [c]\n"
            "            4: [d]\n"
            "            5: [e]\n"
            "            6: [f]\n"
            "            2: [a, b]\n"
            "            3: [b, c]\n"
            "            4: [c, d]\n"
            "            5: [d, e]\n"
            "            6: [e, f]\n"
            "            3: [a, b, c]\n"
            "            4: [b, c, d]\n"
            "            5: [c, d, e]\n"
            "            6: [d, e, f]\n"
            "            4: [a, b, c, d]\n"
            "            5: [b, c, d, e]\n"
            "            6: [c, d, e, f]\n\n"
            "        -- the variable parameter version:\n"
            "        -- probably a little slower, but more flexible\n"
            "        smap(|1>, |4>, |op: print-smap-bracket>) ssplit |abcdef>\n\n"
            "    see also:\n";

    operator_usage_map.map["Gaussian"] =
            "\nGaussian:\n"
            "    description:\n"
            "        Gaussian[sigma] ket\n"
            "        Gaussian[sigma, dx] ket\n"
            "        implements a Gaussian superposition centred on ket, with sigma the standard deviation\n"
            "        if dx is not specified, it defaults to 1, where dx is step size\n\n"
            "    the algorithm:\n"
            "        exp( - ED(x, y) / (2 * sigma ^ 2))\n"
            "        where ED(x, y) is the Euclidean distance between x and y\n\n"
            "    examples:\n"
            "        Gaussian[0.7] |40>\n"
            "            0.016880|36> + 0.046830|37> + 0.129923|38> + 0.360448|39> + |40> + 0.360448|41> + 0.129923|42> + 0.046830|43> + 0.016880|44>\n\n"
            "        -- bar-chart of 1D version:\n"
            "        bar-chart[50] Gaussian[0.7] |age: 35>\n"
            "            ----------\n"
            "            age: 31 : |\n"
            "            age: 32 : ||\n"
            "            age: 33 : ||||||\n"
            "            age: 34 : ||||||||||||||||||\n"
            "            age: 35 : ||||||||||||||||||||||||||||||||||||||||||||||||||\n"
            "            age: 36 : ||||||||||||||||||\n"
            "            age: 37 : ||||||\n"
            "            age: 38 : ||\n"
            "            age: 39 : |\n"
            "            ----------\n\n"
            "        -- 2D version:\n"
            "        Gaussian[0.5] |10: 10>\n"
            "            0.003493|8: 8> + 0.011423|8: 9> + 0.018316|8: 10> + 0.011423|8: 11> + 0.003493|8: 12> + 0.011423|9: 8> + 0.059106|9: 9> + 0.135335|9: 10> + 0.059106|9: 11> + 0.011423|9: 12> + 0.018316|10: 8> + 0.135335|10: 9> + |10: 10> + 0.135335|10: 11> + 0.018316|10: 12> + 0.011423|11: 8> + 0.059106|11: 9> + 0.135335|11: 10> + 0.059106|11: 11> + 0.011423|11: 12> + 0.003493|12: 8> + 0.011423|12: 9> + 0.018316|12: 10> + 0.011423|12: 11> + 0.003493|12: 12>\n\n"
            "    see also:\n";

    operator_usage_map.map["and"] =
            "\nand:\n"
            "    description:\n"
            "        and(ket1, ket2)\n"
            "        returns |yes> if ket1 and ket2 are |yes>, |no> otherwise.\n\n"
            "    examples:\n"
            "        and(|yes>, |yes>)\n"
            "            |yes>\n\n"
            "        and(|yes>, |no>)\n"
            "            |no>\n\n"
            "        and(|no>, |no>)\n"
            "            |no>\n\n"
            "    see also:\n"
            "        or, xor\n"
            "\nand:\n"
            "    description:\n"
            "        and(ket) input-seq\n"
            "        applies and(ket, x) for each x in input-seq\n"
            "        as such, it preserves input-seq structure\n"
            "        but, because it preserves input-seq structure, it is slower than the above version.\n\n"
            "    examples:\n"
            "        and(|yes>) (|no> . |yes>)\n"
            "            |no> . |yes>\n\n"
            "    see also:\n"
            "        or, xor";

    operator_usage_map.map["or"] =
            "\nor:\n"
            "    description:\n"
            "        or(ket1, ket2)\n"
            "        returns |yes> if ket1 or ket2 are |yes>, |no> otherwise.\n\n"
            "    examples:\n"
            "        or(|yes>, |yes>)\n"
            "            |yes>\n\n"
            "        or(|yes>, |no>)\n"
            "            |yes>\n\n"
            "        or(|no>, |no>)\n"
            "            |no>\n\n"
            "    see also:\n"
            "        and, xor\n"
            "\nor:\n"
            "    description:\n"
            "        or(ket) input-seq\n"
            "        applies or(ket, x) for each x in input-seq\n"
            "        as such, it preserves input-seq structure\n"
            "        but, because it preserves input-seq structure, it is slower than the above version.\n\n"
            "    examples:\n"
            "        or(|yes>) (|no> . |yes>)\n"
            "            |yes> . |yes>\n\n"
            "        or(|no>) (|no> . |yes>)\n"
            "            |no> . |yes>\n\n"
            "    see also:\n"
            "        and, xor";

    operator_usage_map.map["xor"] =
            "\nxor:\n"
            "    description:\n"
            "        xor(ket1, ket2)\n"
            "        returns |yes> if ket1 xor ket2 are |yes>, |no> otherwise.\n\n"
            "    examples:\n"
            "        xor(|yes>, |yes>)\n"
            "            |no>\n\n"
            "        xor(|yes>, |no>)\n"
            "            |yes>\n\n"
            "        xor(|no>, |no>)\n"
            "            |no>\n\n"
            "    see also:\n"
            "        and, or\n"
            "\nxor:\n"
            "    description:\n"
            "        xor(ket) input-seq\n"
            "        applies xor(ket, x) for each x in input-seq\n"
            "        as such, it preserves input-seq structure\n"
            "        but, because it preserves input-seq structure, it is slower than the above version.\n\n"
            "    examples:\n"
            "        xor(|yes>) (|no> . |yes>)\n"
            "            |yes> . |no>\n\n"
            "        xor(|no>) (|no> . |yes>)\n"
            "            |no> . |yes>\n\n"
            "    see also:\n"
            "        and, or";

    operator_usage_map.map["find-inverse"] =
            "\nfind-inverse:\n"
            "    description:\n"
            "        find-inverse[op1, op2, ...]\n"
            "        find-inverse[*]\n"
            "        learn the inverses for the given operators\n"
            "        since operators are directed links in a graph, we use this function to learn the inverse links\n\n"
            "    examples:\n"
            "        load fred-sam-friends.sw\n"
            "        find-inverse[friends]\n"
            "        dump\n"
            "            ------------------------------------------\n"
            "            |context> => |Fred Sam friends>\n"
            "\n"
            "            friends |Fred> => |Jack> + |Harry> + |Ed> + |Mary> + |Rob> + |Patrick> + |Emma> + |Charlie>\n"
            "            age |Fred> => |32>\n"
            "\n"
            "            friends |Sam> => |Charlie> + |George> + |Emma> + |Jack> + |Robert> + |Frank> + |Julie>\n"
            "            age |Sam> => |34>\n"
            "\n"
            "            inverse-friends |Jack> => |Fred> + |Sam>\n"
            "\n"
            "            inverse-friends |Harry> => |Fred>\n"
            "\n"
            "            inverse-friends |Ed> => |Fred>\n"
            "\n"
            "            inverse-friends |Mary> => |Fred>\n"
            "\n"
            "            inverse-friends |Rob> => |Fred>\n"
            "\n"
            "            inverse-friends |Patrick> => |Fred>\n"
            "\n"
            "            inverse-friends |Emma> => |Fred> + |Sam>\n"
            "\n"
            "            inverse-friends |Charlie> => |Fred> + |Sam>\n"
            "\n"
            "            inverse-friends |George> => |Sam>\n"
            "\n"
            "            inverse-friends |Robert> => |Sam>\n"
            "\n"
            "            inverse-friends |Frank> => |Sam>\n"
            "\n"
            "            inverse-friends |Julie> => |Sam>\n"
            "\n"
            "\n"
            "            ------------------------------------------\n\n"
            "    see also:\n";

    operator_usage_map.map["has-suffix"] =
            "\nhas-suffix:\n"
            "    description:\n"
            "        has-suffix[\"str\"] ket\n"
            "        returns |yes> if the ket has the given suffix\n\n"
            "    examples:\n"
            "        has-suffix[\"day\"] |Tuesday>\n"
            "            |yes>\n\n"
            "        has-suffix[\"str\"] |Tuesday>\n"
            "            |no>\n"
            "    see also:\n"
            "        has-prefix, remove-suffix, remove-prefix";

    operator_usage_map.map["remove-suffix"] =
            "\nremove-suffix:\n"
            "    description:\n"
            "        remove-suffix[\"str\"] ket\n"
            "        if ket has suffix str then remove it\n\n"
            "    examples:\n"
            "        remove-suffix[\"day\"] |Tuesday>\n"
            "            |Tues>\n\n"
            "        remove-suffix[\"str\"] |Tuesday>\n"
            "            |Tuesday>\n\n"
            "    see also:\n"
            "        remove-prefix, has-suffix, has-prefix";

    operator_usage_map.map["has-prefix"] =
            "\nhas-prefix:\n"
            "    description:\n"
            "        has-prefix[\"str\"] ket\n"
            "        returns |yes> if the ket has the given prefix\n\n"
            "    examples:\n"
            "        has-prefix[\"not \"] |not sitting at the beach>\n"
            "            |yes>\n\n"
            "        has-prefix[\"not \"] |sitting at the beach>\n"
            "            |no>\n\n"
            "    see also:\n"
            "        has-suffix, remove-suffix, remove-prefix";

    operator_usage_map.map["remove-prefix"] =
            "\nremove-prefix:\n"
            "    description:\n"
            "        remove-prefix[\"str\"] ket\n"
            "        if ket has prefix str then remove it\n\n"
            "    examples:\n"
            "        remove-prefix[\"not \"] |not sitting at the beach>\n"
            "            |sitting at the beach>\n\n"
            "        remove-prefix[\"word: \"] |word: table>\n"
            "            |table>\n\n"
            "        remove-prefix[\"food: \"] |word: chair>\n"
            "            |word: chair>\n\n"
            "    see also:\n"
            "        remove-suffix, has-suffix, has-prefix";

    operator_usage_map.map["to-comma-number"] =
            "\nto-comma-number:\n"
            "    description:\n"
            "        to-comma-number ket\n"
            "        insert thousands commas into numbers\n\n"
            "    examples:\n"
            "        to-comma-number |8825>\n"
            "            |8,825>\n\n"
            "        to-comma-number |population: 2300000>\n"
            "            |population: 2,300,000>\n\n"
            "        to-comma-number |km: 22956.53>\n"
            "            |km: 22,956.53>\n\n"
            "    see also:\n"
            "        table, round";

    operator_usage_map.map["union"] =
            "\nunion:\n"
            "    description:\n"
            "        union(seq, seq)\n"
            "        the union function, takes element-wise max of the coefficients\n"
            "        it generalizes standard set union where the coefficients are either 0 or 1\n"
            "        ie, it is a fuzzy set union\n\n"
            "    examples:\n"
            "        -- set union of {a,b,c,d} and {b,d,e,f,g}:\n"
            "        union(split |abcd>, split |bdefg>)\n"
            "            |a> + |b> + |c> + |d> + |e> + |f> + |g>\n\n"
            "        -- fuzzy set union example:\n"
            "        union(3|a> + 1.2|b>, 3.5|a> + 0.9|b> + 5.13|c>)\n"
            "            3.500000|a> + 1.200000|b> + 5.130000|c>\n\n"
            "    see also:\n"
            "        intersection, is-subset, is-mbr, simm";

    operator_usage_map.map["intersection"] =
            "\nintersection:\n"
            "    description:\n"
            "        intersection(seq, seq)\n"
            "        the intersection function, takes element-wise min of the coefficients\n"
            "        it generalizes standard set intersection where the coefficients are either 0 or 1\n"
            "        ie, it is a fuzzy set intersection\n\n"
            "    examples:\n"
            "        -- set intersection of {a,b,c,d} and {b,d,e,f,g}:\n"
            "        intersection(split |abcd>, split |bdefg>)\n"
            "            |b> + |d>\n\n"
            "        -- fuzzy set intersection example:\n"
            "        intersection(3|a> + 1.2|b>, 3.5|a> + 0.9|b> + 5.13|c>)\n"
            "            3|a> + 0.900000|b>\n\n"
            "    see also:\n"
            "        union, is-subset, is-mbr, simm";

    operator_usage_map.map["select"] =
            "\nselect:\n"
            "    description:\n"
            "        select[k1, k2] sp\n"
            "        select the k1'th to the k2'th elements from the given superposition\n"
            "        indices start from 1, not 0\n"
            "        also, final element has index -1, 2nd last element -2, and so on.\n\n"
            "    examples:\n"
            "        select[2, 4] split |abcdefg>\n"
            "            |b> + |c> + |d>\n\n"
            "        select[-3, -1] split |abcdefg>\n"
            "            |e> + |f> + |g>\n\n"
            "    see also:\n"
            "        sselect";

    operator_usage_map.map["sselect"] =
            "\nsselect:\n"
            "    description:\n"
            "        sselect[k1, k2] seq\n"
            "        select the k1'th to the k2'th elements from the given sequence\n"
            "        indices start from 1, not 0\n"
            "        also, final element has index -1, 2nd last element -2, and so on.\n\n"
            "    examples:\n"
            "        sselect[2, 4] ssplit |abcdefg>\n"
            "            |b> . |c> . |d>\n\n"
            "        sselect[-3, -1] ssplit |abcdefg>\n"
            "            |e> . |f> . |g>\n\n"
            "    see also:\n"
            "        select";

    operator_usage_map.map["find-path-between"] =
            "\nfind-path-between:\n"
            "    description:\n"
            "        find-path-between(ket1, ket2)\n"
            "        Use Dijkstra's algorithm to find the shortest path between ket1 and ket2\n"
            "        See: https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm\n"
            "        To instead find the operators required to get from ket1 to ket2 see find-operators-between().\n\n"
            "    examples:\n"
            "        -- learn a grid, then find a path:\n"
            "        learn-grid[10, 10]\n"
            "        find-path-between(|grid: 0: 0>, |grid: 5: 5>)\n"
            "            |grid: 0: 0> . |grid: 1: 1> . |grid: 2: 2> . |grid: 3: 3> . |grid: 4: 4> . |grid: 5: 5>\n\n"
            "    see also:\n"
            "        find-operators-between";

    operator_usage_map.map["find-operators-between"] =
            "\nfind-operators-between:\n"
            "    description:\n"
            "        find-operators-between(ket1, ket2)\n"
            "        Use Dijkstra's algorithm to find the shortest path between ket1 and ket2\n"
            "        See: https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm\n"
            "        Same as find-path-between(), except we instead return the operator sequence required to get from ket1 to ket2\n\n"
            "    examples:\n"
            "        -- learn a grid, then find a path:\n"
            "        learn-grid[10, 10]\n"
            "        find-operators-between(|grid: 0: 0>, |grid: 5: 6>)\n"
            "            |op: E> . |op: SE> . |op: SE> . |op: SE> . |op: SE> . |op: SE>\n\n"
            "        -- a quick demonstration that this is correct:\n"
            "        SE SE SE SE SE E |grid: 0: 0>\n"
            "            |grid: 5: 6>\n\n\n"
            "        -- find pathway through a friend network:\n"
            "        -- first define some friends:\n"
            "        friends |Fred> => |Jack> + |Harry> + |Ed> + |Mary> + |Rob> + |Patrick> + |Emma> + |Charlie>\n"
            "        friends |Sam> => |Charlie> + |George> + |Emma> + |Jack> + |Robert> + |Frank> + |Julie>\n\n"
            "        -- find inverse friends links:\n"
            "        find-inverse[friends]\n\n"
            "        -- find friend pathway from Fred to Sam:\n"
            "        find-operators-between(|Fred>, |Sam>)\n"
            "            |op: friends> . |op: inverse-friends>\n\n"
            "        -- find friend pathway from Fred to Julie:\n"
            "        find-operators-between(|Fred>, |Julie>)\n"
            "            |op: friends> . |op: inverse-friends> . |op: friends>\n\n"
            "        -- verify we reach Julie using this operator sequence:\n"
            "        friends inverse-friends friends |Fred>\n"
            "            11|Jack> + 8|Harry> + 8|Ed> + 8|Mary> + 8|Rob> + 8|Patrick> + 11|Emma> + 11|Charlie> + 3|George> + 3|Robert> + 3|Frank> + 3|Julie>\n\n"
            "    see also:\n"
            "        find-path-between, find-inverse";

    operator_usage_map.map["unlearn"] =
            "\nunlearn:\n"
            "    description:\n"
            "        unlearn[op1, op2, ..., opn] sp\n"
            "        unlearn the given operator(s) for all the kets in sp\n"
            "        In some cases where an object has a lot of learn rules, it could be slow\n\n"
            "    examples:\n"
            "        -- load some toy knowledge:\n"
            "        load fred-sam-friends.sw3\n\n"
            "        -- see what we know:\n"
            "        dump verbose\n"
            "            ------------------------------------------\n"
            "            |context> => |Fred Sam friends>\n\n"
            "            supported-ops |Fred> => |op: friends> + |op: age>\n"
            "            friends |Fred> => |Jack> + |Harry> + |Ed> + |Mary> + |Rob> + |Patrick> + |Emma> + |Charlie>\n"
            "            age |Fred> => |32>\n\n"
            "            supported-ops |Sam> => |op: friends> + |op: age>\n"
            "            friends |Sam> => |Charlie> + |George> + |Emma> + |Jack> + |Robert> + |Frank> + |Julie>\n"
            "            age |Sam> => |34>\n"
            "            ------------------------------------------\n\n"
            "        -- now delete the age operator for Fred:\n"
            "        unlearn[age] |Fred>\n\n"
            "        -- see what we now know:\n"
            "        dump verbose\n"
            "            ------------------------------------------\n"
            "            |context> => |Fred Sam friends>\n\n"
            "            supported-ops |Fred> => |op: friends>\n"
            "            friends |Fred> => |Jack> + |Harry> + |Ed> + |Mary> + |Rob> + |Patrick> + |Emma> + |Charlie>\n\n"
            "            supported-ops |Sam> => |op: friends> + |op: age>\n"
            "            friends |Sam> => |Charlie> + |George> + |Emma> + |Jack> + |Robert> + |Frank> + |Julie>\n"
            "            age |Sam> => |34>\n"
            "            ------------------------------------------\n\n"
            "        -- now delete the friends operator for Fred:\n"
            "        unlearn[friends] |fred>\n\n"
            "        -- see what we now know:\n"
            "        dump verbose\n"
            "            ------------------------------------------\n"
            "            |context> => |Fred Sam friends>\n\n"
            "            supported-ops |Fred> => |>\n\n"
            "            supported-ops |Sam> => |op: friends> + |op: age>\n"
            "            friends |Sam> => |Charlie> + |George> + |Emma> + |Jack> + |Robert> + |Frank> + |Julie>\n"
            "            age |Sam> => |34>\n"
            "            ------------------------------------------\n\n"
            "    see also:\n";

    operator_usage_map.map["sshuffle"] =
            "\nsshuffle:\n"
            "    description:\n"
            "        sshuffle seq\n"
            "        randomly shuffle the input sequence\n\n"
            "    examples:\n"
            "        sshuffle (|one> . |two> . |three> . |four> . |five>)\n"
            "            |two> . |four> . |five> . |three> . |one>\n\n"
            "    see also:\n"
            "        shuffle";

    operator_usage_map.map["shuffle"] =
            "\nshuffle:\n"
            "    description:\n"
            "        shuffle seq\n"
            "        randomly shuffle each superposition in the input sequence\n\n"
            "    examples:\n"
            "        shuffle (|one> + |two> + |three> + |four> + |five> . |x> + |y> + |z>)\n"
            "            |one> + |four> + |two> + |three> + |five> . |z> + |x> + |y>\n\n"
            "    see also:\n"
            "        sshuffle";

    operator_usage_map.map["sidx"] =
            "\nsidx:\n"
            "    description:\n"
            "        sidx input-seq\n"
            "        map superpositions in a sequence to their index number\n"
            "        NB: counting starts from 1 not 0\n"
            "        The original use case for this operator failed, so may delete this operator in the future\n\n"
            "    examples:\n"
            "        sidx (|a> . |b> . |c> . |d> . |e>)\n"
            "            |1> . |2> . |3> . |4> . |5>\n\n"
            "    see also:\n";

}

std::string OperatorUsageMap::get_usage(const std::string &s) const {
    auto it = map.find(s);
    if (it == map.end()) { return ""; }
    return it->second;
}

bool OperatorUsageMap::usage_is_defined(const std::string &s) const {
    auto it = map.find(s);
    return it != map.end();
}